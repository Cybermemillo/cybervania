{
    "sourceFile": "js/entities/Player.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1741025480108,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1741025548730,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,8 +46,21 @@\n             losses: 0,\r\n             floors: 1\r\n         };\r\n         \r\n+        // Sistema de menú principal\r\n+        this.menuSettings = {\r\n+            lastSaveDate: data.lastSaveDate || null,\r\n+            gameOptions: data.gameOptions || {\r\n+                musicVolume: 0.7,\r\n+                sfxVolume: 0.8,\r\n+                fullscreen: false,\r\n+                difficulty: 'normal',\r\n+                language: 'es'\r\n+            },\r\n+            saveSlots: data.saveSlots || [null, null, null]\r\n+        };\r\n+        \r\n         // Aplicar bonificaciones según especialización\r\n         this.applySpecializationBonuses();\r\n     }\r\n     \r\n@@ -205,9 +218,9 @@\n                     }\r\n                     break;\r\n                     \r\n                 // Más casos para otros tipos de efectos\r\n-                \r\n+                    \r\n                 case 'turn_start':\r\n                     if (artifact.id === 'vpn_shield') {\r\n                         this.gainDefense(artifact.value);\r\n                     }\r\n@@ -349,13 +362,172 @@\n             offensiveSkill: this.offensiveSkill,\r\n             defensiveSkill: this.defensiveSkill,\r\n             artifacts: this.artifacts,\r\n             potions: this.potions,\r\n-            stats: this.stats\r\n+            stats: this.stats,\r\n+            lastSaveDate: new Date().toISOString(),\r\n+            menuSettings: this.menuSettings\r\n         };\r\n     }\r\n     \r\n     static deserialize(data) {\r\n         // Crear jugador desde datos guardados\r\n         return new Player(data);\r\n     }\r\n+    \r\n+    // Métodos nuevos para el sistema de menú\r\n+    \r\n+    /**\r\n+     * Guarda el estado actual del jugador en un slot específico\r\n+     * @param {number} slotIndex - Índice del slot de guardado (0-2)\r\n+     * @returns {boolean} - True si se guardó correctamente\r\n+     */\r\n+    saveGame(slotIndex) {\r\n+        if (slotIndex < 0 || slotIndex > 2) return false;\r\n+        \r\n+        const saveData = this.serialize();\r\n+        this.menuSettings.saveSlots[slotIndex] = {\r\n+            playerName: this.name,\r\n+            specialization: this.specialization,\r\n+            level: this.stats.floors,\r\n+            timestamp: new Date().toISOString(),\r\n+            preview: {\r\n+                health: this.health,\r\n+                maxHealth: this.maxHealth,\r\n+                credits: this.credits\r\n+            },\r\n+            fullData: saveData\r\n+        };\r\n+        \r\n+        // Actualizar localStorage (suponiendo implementación futura)\r\n+        this._persistSaveData();\r\n+        return true;\r\n+    }\r\n+    \r\n+    /**\r\n+     * Carga una partida guardada desde un slot específico\r\n+     * @param {number} slotIndex - Índice del slot de guardado (0-2)\r\n+     * @returns {Player|null} - Instancia del jugador cargada o null si no hay datos\r\n+     */\r\n+    static loadGame(slotIndex) {\r\n+        // Esta función tendría que implementarse en el sistema real\r\n+        // Aquí solo simulamos la recuperación de datos\r\n+        const savedData = Player._getSavedDataFromStorage(slotIndex);\r\n+        if (!savedData) return null;\r\n+        \r\n+        return Player.deserialize(savedData.fullData);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Inicia una nueva partida con la especialización seleccionada\r\n+     * @param {string} playerName - Nombre del jugador\r\n+     * @param {string} specialization - Especialización: 'red', 'blue', o 'purple'\r\n+     * @returns {Player} - Nueva instancia del jugador\r\n+     */\r\n+    static startNewGame(playerName, specialization) {\r\n+        return new Player({\r\n+            name: playerName,\r\n+            specialization: specialization\r\n+        });\r\n+    }\r\n+    \r\n+    /**\r\n+     * Obtiene información sobre las partidas guardadas para mostrar en el menú\r\n+     * @returns {Array} - Información resumida de las partidas guardadas\r\n+     */\r\n+    static getSaveSlotInfo() {\r\n+        // Simulación - en implementación real, esto leería de localStorage\r\n+        const saveInfo = [];\r\n+        \r\n+        // Recuperar información de los slots desde almacenamiento\r\n+        for (let i = 0; i < 3; i++) {\r\n+            const slotData = Player._getSavedDataFromStorage(i);\r\n+            \r\n+            if (slotData) {\r\n+                saveInfo.push({\r\n+                    slotIndex: i,\r\n+                    playerName: slotData.playerName,\r\n+                    specialization: slotData.specialization,\r\n+                    level: slotData.level,\r\n+                    timestamp: new Date(slotData.timestamp),\r\n+                    isEmpty: false\r\n+                });\r\n+            } else {\r\n+                saveInfo.push({\r\n+                    slotIndex: i,\r\n+                    isEmpty: true\r\n+                });\r\n+            }\r\n+        }\r\n+        \r\n+        return saveInfo;\r\n+    }\r\n+    \r\n+    /**\r\n+     * Obtiene o actualiza las opciones de juego\r\n+     * @param {Object} newOptions - Nuevas opciones (opcional)\r\n+     * @returns {Object} - Opciones actuales\r\n+     */\r\n+    getGameOptions(newOptions = null) {\r\n+        if (newOptions) {\r\n+            this.menuSettings.gameOptions = {\r\n+                ...this.menuSettings.gameOptions,\r\n+                ...newOptions\r\n+            };\r\n+            this._persistSaveData();\r\n+        }\r\n+        \r\n+        return this.menuSettings.gameOptions;\r\n+    }\r\n+    \r\n+    /**\r\n+     * Genera datos del menú principal con temas gótico-cyberpunk\r\n+     * @returns {Object} - Datos de UI para el menú principal\r\n+     */\r\n+    static getMainMenuTheme() {\r\n+        return {\r\n+            title: \"CYBERVANIA\",\r\n+            subtitle: \"Donde la oscuridad se encuentra con el código\",\r\n+            menuPosition: \"bottom-right\", // Ubicado para no bloquear la vista del castillo\r\n+            menuItems: [\r\n+                { id: \"new-game\", text: \"Nueva Partida\", icon: \"glyph-plus\" },\r\n+                { id: \"load-game\", text: \"Cargar Partida\", icon: \"glyph-load\" },\r\n+                { id: \"options\", text: \"Opciones\", icon: \"glyph-gear\" },\r\n+                { id: \"exit\", text: \"Salir\", icon: \"glyph-power\" }\r\n+            ],\r\n+            uiElements: {\r\n+                font: \"NeoGothic\",\r\n+                cursor: \"cyber-garra\",\r\n+                hoverEffect: \"glitch-subtle\",\r\n+                backgroundBlur: 0.15,\r\n+                mistOpacity: 0.3,\r\n+                menuFrameColor: \"rgba(41, 80, 120, 0.8)\",\r\n+                textGlowColor: \"rgba(0, 195, 255, 0.5)\",\r\n+                buttonStyle: \"semi-transparent\"\r\n+            },\r\n+            animations: {\r\n+                menuEntrance: \"fade-from-mist\",\r\n+                buttonHover: \"pulse-neon\",\r\n+                transition: \"digital-dissolve\"\r\n+            },\r\n+            audio: {\r\n+                backgroundTrack: \"gothic-synth-ambience\",\r\n+                hoverSound: \"soft-digital-click\",\r\n+                selectSound: \"electric-confirm\"\r\n+            }\r\n+        };\r\n+    }\r\n+    \r\n+    // Métodos privados de ayuda\r\n+    \r\n+    _persistSaveData() {\r\n+        // Simula la persistencia de datos\r\n+        // En implementación real usaría localStorage u otro sistema de guardado\r\n+        console.log(\"Datos de juego guardados\");\r\n+    }\r\n+    \r\n+    static _getSavedDataFromStorage(slotIndex) {\r\n+        // Simula la recuperación de datos\r\n+        // En implementación real leería de localStorage u otro sistema\r\n+        return null; // No hay implementación real en este ejemplo\r\n+    }\r\n }\r\n"
                },
                {
                    "date": 1741028558298,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,8 +2,10 @@\n     constructor(data = {}) {\r\n         // Datos básicos\r\n         this.name = data.name || 'Hacker';\r\n         this.specialization = data.specialization || 'neutral';\r\n+        this.gender = data.gender || 'male'; // Nuevo campo para género\r\n+        this.backstory = data.backstory || ''; // Nuevo campo para historia\r\n         \r\n         // Atributos principales\r\n         this.health = data.health || 70;\r\n         this.maxHealth = data.maxHealth || 70;\r\n@@ -420,14 +422,18 @@\n     /**\r\n      * Inicia una nueva partida con la especialización seleccionada\r\n      * @param {string} playerName - Nombre del jugador\r\n      * @param {string} specialization - Especialización: 'red', 'blue', o 'purple'\r\n+     * @param {string} gender - Género: 'male' o 'female'\r\n+     * @param {string} backstory - Historia de fondo o motivación del personaje\r\n      * @returns {Player} - Nueva instancia del jugador\r\n      */\r\n-    static startNewGame(playerName, specialization) {\r\n+    static startNewGame(playerName, specialization, gender, backstory) {\r\n         return new Player({\r\n             name: playerName,\r\n-            specialization: specialization\r\n+            specialization: specialization,\r\n+            gender: gender,\r\n+            backstory: backstory\r\n         });\r\n     }\r\n     \r\n     /**\r\n"
                }
            ],
            "date": 1741025480108,
            "name": "Commit-0",
            "content": "export class Player {\r\n    constructor(data = {}) {\r\n        // Datos básicos\r\n        this.name = data.name || 'Hacker';\r\n        this.specialization = data.specialization || 'neutral';\r\n        \r\n        // Atributos principales\r\n        this.health = data.health || 70;\r\n        this.maxHealth = data.maxHealth || 70;\r\n        this.defense = data.defense || 0;\r\n        this.actionPoints = data.actionPoints || 3;\r\n        this.maxActionPoints = data.maxActionPoints || 3;\r\n        \r\n        // Recursos\r\n        this.credits = data.credits || 100;\r\n        \r\n        // Habilidades\r\n        this.offensiveSkill = data.offensiveSkill || 1;\r\n        this.defensiveSkill = data.defensiveSkill || 1;\r\n        \r\n        // Inventario\r\n        this.artifacts = data.artifacts || [];\r\n        this.potions = data.potions || [];\r\n        \r\n        // Estados de combate\r\n        this.status = {\r\n            vulnerable: 0,\r\n            weak: 0,\r\n            poisoned: 0,\r\n            burning: 0,\r\n            strength: 0,\r\n            dexterity: 0\r\n        };\r\n        \r\n        // Estadísticas\r\n        this.stats = {\r\n            enemiesDefeated: 0,\r\n            damageDealt: 0,\r\n            damageReceived: 0,\r\n            cardsPlayed: 0,\r\n            creditsCollected: 0,\r\n            elitesKilled: 0,\r\n            bossesKilled: 0,\r\n            turnsPlayed: 0,\r\n            maxCombo: 0,\r\n            losses: 0,\r\n            floors: 1\r\n        };\r\n        \r\n        // Sistema de menú principal\r\n        this.menuSettings = {\r\n            lastSaveDate: data.lastSaveDate || null,\r\n            gameOptions: data.gameOptions || {\r\n                musicVolume: 0.7,\r\n                sfxVolume: 0.8,\r\n                fullscreen: false,\r\n                difficulty: 'normal',\r\n                language: 'es'\r\n            },\r\n            saveSlots: data.saveSlots || [null, null, null]\r\n        };\r\n        \r\n        // Aplicar bonificaciones según especialización\r\n        this.applySpecializationBonuses();\r\n    }\r\n    \r\n    applySpecializationBonuses() {\r\n        switch (this.specialization) {\r\n            case 'red': // Ataque\r\n                this.offensiveSkill += 1;\r\n                break;\r\n                \r\n            case 'blue': // Defensa\r\n                this.defensiveSkill += 1;\r\n                this.maxHealth += 5;\r\n                this.health += 5;\r\n                break;\r\n                \r\n            case 'purple': // Equilibrado\r\n                this.maxActionPoints += 1;\r\n                this.actionPoints += 1;\r\n                break;\r\n        }\r\n    }\r\n    \r\n    takeDamage(amount) {\r\n        // Aplicar vulnerabilidad si corresponde\r\n        if (this.status.vulnerable > 0) {\r\n            amount = Math.floor(amount * 1.5);\r\n        }\r\n        \r\n        // Reducir daño por defensa\r\n        let actualDamage = amount;\r\n        if (this.defense > 0) {\r\n            if (amount <= this.defense) {\r\n                this.defense -= amount;\r\n                actualDamage = 0;\r\n            } else {\r\n                actualDamage = amount - this.defense;\r\n                this.defense = 0;\r\n            }\r\n        }\r\n        \r\n        // Aplicar daño y registrar estadísticas\r\n        this.health = Math.max(0, this.health - actualDamage);\r\n        this.stats.damageReceived += actualDamage;\r\n        \r\n        return {\r\n            damageTaken: actualDamage,\r\n            remainingDefense: this.defense,\r\n            remainingHealth: this.health\r\n        };\r\n    }\r\n    \r\n    heal(amount) {\r\n        // No permitir curar más allá de la salud máxima\r\n        const actualHeal = Math.min(amount, this.maxHealth - this.health);\r\n        this.health += actualHeal;\r\n        \r\n        return actualHeal;\r\n    }\r\n    \r\n    gainDefense(amount) {\r\n        // Aplicar bonificaciones de destreza\r\n        if (this.status.dexterity > 0) {\r\n            amount += this.status.dexterity;\r\n        }\r\n        \r\n        // Aplicar efectos de artefactos\r\n        amount = this.applyArtifactEffects('defense_gain', amount);\r\n        \r\n        this.defense += amount;\r\n        return amount;\r\n    }\r\n    \r\n    spendActionPoints(amount) {\r\n        // No permitir gastar más de los puntos disponibles\r\n        if (amount > this.actionPoints) {\r\n            return false;\r\n        }\r\n        \r\n        this.actionPoints -= amount;\r\n        return true;\r\n    }\r\n    \r\n    gainActionPoints(amount) {\r\n        this.actionPoints = Math.min(this.maxActionPoints, this.actionPoints + amount);\r\n        return this.actionPoints;\r\n    }\r\n    \r\n    resetActionPoints() {\r\n        this.actionPoints = this.maxActionPoints;\r\n        return this.actionPoints;\r\n    }\r\n    \r\n    addArtifact(artifact) {\r\n        // Aplicar efectos inmediatos si los hay\r\n        if (artifact.immediateEffect) {\r\n            this.applyArtifactImmediateEffect(artifact);\r\n        }\r\n        \r\n        // Añadir al inventario\r\n        this.artifacts.push(artifact);\r\n    }\r\n    \r\n    hasArtifact(artifactId) {\r\n        return this.artifacts.some(artifact => artifact.id === artifactId);\r\n    }\r\n    \r\n    removeArtifact(artifactId) {\r\n        const index = this.artifacts.findIndex(a => a.id === artifactId);\r\n        if (index !== -1) {\r\n            const artifact = this.artifacts[index];\r\n            this.artifacts.splice(index, 1);\r\n            return artifact;\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    applyArtifactImmediateEffect(artifact) {\r\n        switch (artifact.id) {\r\n            case 'usb_booster':\r\n                this.maxActionPoints += 1;\r\n                this.actionPoints += 1;\r\n                break;\r\n                \r\n            case 'medical_kit':\r\n                this.heal(Math.floor(this.maxHealth * 0.3));\r\n                break;\r\n                \r\n            case 'skill_chip':\r\n                this.offensiveSkill += 1;\r\n                this.defensiveSkill += 1;\r\n                break;\r\n                \r\n            case 'upgrade_module':\r\n                this.maxHealth += 10;\r\n                this.health += 10;\r\n                break;\r\n        }\r\n    }\r\n    \r\n    applyArtifactEffects(triggerType, value) {\r\n        let modifiedValue = value;\r\n        \r\n        for (const artifact of this.artifacts) {\r\n            switch (triggerType) {\r\n                case 'defense_gain':\r\n                    if (artifact.id === 'encryption_key') {\r\n                        modifiedValue += artifact.value;\r\n                    }\r\n                    break;\r\n                    \r\n                case 'damage_dealt':\r\n                    if (artifact.id === 'rootkit_module' && this.isFirstCardOfCombat) {\r\n                        modifiedValue += artifact.value;\r\n                        this.isFirstCardOfCombat = false;\r\n                    }\r\n                    break;\r\n                    \r\n                // Más casos para otros tipos de efectos\r\n                    \r\n                case 'turn_start':\r\n                    if (artifact.id === 'vpn_shield') {\r\n                        this.gainDefense(artifact.value);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        \r\n        return modifiedValue;\r\n    }\r\n    \r\n    processStatusEffects() {\r\n        // Procesar efectos de estado al inicio del turno\r\n        let damageFromStatus = 0;\r\n        \r\n        // Veneno\r\n        if (this.status.poisoned > 0) {\r\n            const poisonDamage = Math.ceil(this.status.poisoned / 2);\r\n            this.health -= poisonDamage;\r\n            damageFromStatus += poisonDamage;\r\n            this.status.poisoned--;\r\n        }\r\n        \r\n        // Quemadura\r\n        if (this.status.burning > 0) {\r\n            const burnDamage = 3;\r\n            this.health -= burnDamage;\r\n            damageFromStatus += burnDamage;\r\n            this.status.burning--;\r\n        }\r\n        \r\n        // Disminuir duración de otros estados\r\n        for (const status in this.status) {\r\n            if (status !== 'poisoned' && status !== 'burning' && \r\n                status !== 'strength' && status !== 'dexterity') {\r\n                if (this.status[status] > 0) {\r\n                    this.status[status]--;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return damageFromStatus;\r\n    }\r\n    \r\n    startCombat() {\r\n        // Reiniciar estados al inicio del combate\r\n        this.defense = 0;\r\n        this.actionPoints = this.maxActionPoints;\r\n        this.isFirstCardOfCombat = true;\r\n        \r\n        // Reiniciar estados temporales\r\n        this.status = {\r\n            vulnerable: 0,\r\n            weak: 0,\r\n            poisoned: 0,\r\n            burning: 0,\r\n            strength: 0,\r\n            dexterity: 0\r\n        };\r\n        \r\n        // Aplicar efectos de artefactos al inicio del combate\r\n        for (const artifact of this.artifacts) {\r\n            if (artifact.effect === 'start_vulnerable' && artifact.id === 'rootkit_module') {\r\n                // Este se maneja desde el lado de la escena de combate\r\n            }\r\n        }\r\n    }\r\n    \r\n    endCombat() {\r\n        // Limpiar estados al final del combate\r\n        this.defense = 0;\r\n        this.status = {\r\n            vulnerable: 0,\r\n            weak: 0,\r\n            poisoned: 0,\r\n            burning: 0,\r\n            strength: 0,\r\n            dexterity: 0\r\n        };\r\n    }\r\n    \r\n    hasSpecialRestOption() {\r\n        // Verificar si tiene artefactos que otorguen opciones especiales de descanso\r\n        return this.artifacts.some(artifact => artifact.id === 'neural_implant');\r\n    }\r\n    \r\n    getSpecialRestOption() {\r\n        // Devolver opción especial de descanso según artefactos\r\n        if (this.hasArtifact('neural_implant')) {\r\n            return {\r\n                id: 'neural_upgrade',\r\n                name: 'Mejora Neural',\r\n                description: 'Duplica una carta de tu mazo.',\r\n                effect: 'duplicate_card'\r\n            };\r\n        }\r\n        \r\n        return null;\r\n    }\r\n    \r\n    levelUp() {\r\n        // Aumentar atributos al subir nivel\r\n        this.maxHealth += 5;\r\n        this.health += 5;\r\n        \r\n        // Aumentar habilidades según especialización\r\n        if (this.specialization === 'red') {\r\n            this.offensiveSkill += 1;\r\n        } else if (this.specialization === 'blue') {\r\n            this.defensiveSkill += 1;\r\n        } else {\r\n            // Para purple o cualquier otra\r\n            if (Math.random() < 0.5) {\r\n                this.offensiveSkill += 1;\r\n            } else {\r\n                this.defensiveSkill += 1;\r\n            }\r\n        }\r\n        \r\n        this.stats.floors++;\r\n        \r\n        return {\r\n            newMaxHealth: this.maxHealth,\r\n            offensiveSkill: this.offensiveSkill,\r\n            defensiveSkill: this.defensiveSkill\r\n        };\r\n    }\r\n    \r\n    serialize() {\r\n        // Convertir a formato para guardado\r\n        return {\r\n            name: this.name,\r\n            specialization: this.specialization,\r\n            health: this.health,\r\n            maxHealth: this.maxHealth,\r\n            defense: this.defense,\r\n            actionPoints: this.actionPoints,\r\n            maxActionPoints: this.maxActionPoints,\r\n            credits: this.credits,\r\n            offensiveSkill: this.offensiveSkill,\r\n            defensiveSkill: this.defensiveSkill,\r\n            artifacts: this.artifacts,\r\n            potions: this.potions,\r\n            stats: this.stats,\r\n            lastSaveDate: new Date().toISOString(),\r\n            menuSettings: this.menuSettings\r\n        };\r\n    }\r\n    \r\n    static deserialize(data) {\r\n        // Crear jugador desde datos guardados\r\n        return new Player(data);\r\n    }\r\n    \r\n    // Métodos nuevos para el sistema de menú\r\n    \r\n    /**\r\n     * Guarda el estado actual del jugador en un slot específico\r\n     * @param {number} slotIndex - Índice del slot de guardado (0-2)\r\n     * @returns {boolean} - True si se guardó correctamente\r\n     */\r\n    saveGame(slotIndex) {\r\n        if (slotIndex < 0 || slotIndex > 2) return false;\r\n        \r\n        const saveData = this.serialize();\r\n        this.menuSettings.saveSlots[slotIndex] = {\r\n            playerName: this.name,\r\n            specialization: this.specialization,\r\n            level: this.stats.floors,\r\n            timestamp: new Date().toISOString(),\r\n            preview: {\r\n                health: this.health,\r\n                maxHealth: this.maxHealth,\r\n                credits: this.credits\r\n            },\r\n            fullData: saveData\r\n        };\r\n        \r\n        // Actualizar localStorage (suponiendo implementación futura)\r\n        this._persistSaveData();\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Carga una partida guardada desde un slot específico\r\n     * @param {number} slotIndex - Índice del slot de guardado (0-2)\r\n     * @returns {Player|null} - Instancia del jugador cargada o null si no hay datos\r\n     */\r\n    static loadGame(slotIndex) {\r\n        // Esta función tendría que implementarse en el sistema real\r\n        // Aquí solo simulamos la recuperación de datos\r\n        const savedData = Player._getSavedDataFromStorage(slotIndex);\r\n        if (!savedData) return null;\r\n        \r\n        return Player.deserialize(savedData.fullData);\r\n    }\r\n    \r\n    /**\r\n     * Inicia una nueva partida con la especialización seleccionada\r\n     * @param {string} playerName - Nombre del jugador\r\n     * @param {string} specialization - Especialización: 'red', 'blue', o 'purple'\r\n     * @returns {Player} - Nueva instancia del jugador\r\n     */\r\n    static startNewGame(playerName, specialization) {\r\n        return new Player({\r\n            name: playerName,\r\n            specialization: specialization\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Obtiene información sobre las partidas guardadas para mostrar en el menú\r\n     * @returns {Array} - Información resumida de las partidas guardadas\r\n     */\r\n    static getSaveSlotInfo() {\r\n        // Simulación - en implementación real, esto leería de localStorage\r\n        const saveInfo = [];\r\n        \r\n        // Recuperar información de los slots desde almacenamiento\r\n        for (let i = 0; i < 3; i++) {\r\n            const slotData = Player._getSavedDataFromStorage(i);\r\n            \r\n            if (slotData) {\r\n                saveInfo.push({\r\n                    slotIndex: i,\r\n                    playerName: slotData.playerName,\r\n                    specialization: slotData.specialization,\r\n                    level: slotData.level,\r\n                    timestamp: new Date(slotData.timestamp),\r\n                    isEmpty: false\r\n                });\r\n            } else {\r\n                saveInfo.push({\r\n                    slotIndex: i,\r\n                    isEmpty: true\r\n                });\r\n            }\r\n        }\r\n        \r\n        return saveInfo;\r\n    }\r\n    \r\n    /**\r\n     * Obtiene o actualiza las opciones de juego\r\n     * @param {Object} newOptions - Nuevas opciones (opcional)\r\n     * @returns {Object} - Opciones actuales\r\n     */\r\n    getGameOptions(newOptions = null) {\r\n        if (newOptions) {\r\n            this.menuSettings.gameOptions = {\r\n                ...this.menuSettings.gameOptions,\r\n                ...newOptions\r\n            };\r\n            this._persistSaveData();\r\n        }\r\n        \r\n        return this.menuSettings.gameOptions;\r\n    }\r\n    \r\n    /**\r\n     * Genera datos del menú principal con temas gótico-cyberpunk\r\n     * @returns {Object} - Datos de UI para el menú principal\r\n     */\r\n    static getMainMenuTheme() {\r\n        return {\r\n            title: \"CYBERVANIA\",\r\n            subtitle: \"Donde la oscuridad se encuentra con el código\",\r\n            menuPosition: \"bottom-right\", // Ubicado para no bloquear la vista del castillo\r\n            menuItems: [\r\n                { id: \"new-game\", text: \"Nueva Partida\", icon: \"glyph-plus\" },\r\n                { id: \"load-game\", text: \"Cargar Partida\", icon: \"glyph-load\" },\r\n                { id: \"options\", text: \"Opciones\", icon: \"glyph-gear\" },\r\n                { id: \"exit\", text: \"Salir\", icon: \"glyph-power\" }\r\n            ],\r\n            uiElements: {\r\n                font: \"NeoGothic\",\r\n                cursor: \"cyber-garra\",\r\n                hoverEffect: \"glitch-subtle\",\r\n                backgroundBlur: 0.15,\r\n                mistOpacity: 0.3,\r\n                menuFrameColor: \"rgba(41, 80, 120, 0.8)\",\r\n                textGlowColor: \"rgba(0, 195, 255, 0.5)\",\r\n                buttonStyle: \"semi-transparent\"\r\n            },\r\n            animations: {\r\n                menuEntrance: \"fade-from-mist\",\r\n                buttonHover: \"pulse-neon\",\r\n                transition: \"digital-dissolve\"\r\n            },\r\n            audio: {\r\n                backgroundTrack: \"gothic-synth-ambience\",\r\n                hoverSound: \"soft-digital-click\",\r\n                selectSound: \"electric-confirm\"\r\n            }\r\n        };\r\n    }\r\n    \r\n    // Métodos privados de ayuda\r\n    \r\n    _persistSaveData() {\r\n        // Simula la persistencia de datos\r\n        // En implementación real usaría localStorage u otro sistema de guardado\r\n        console.log(\"Datos de juego guardados\");\r\n    }\r\n    \r\n    static _getSavedDataFromStorage(slotIndex) {\r\n        // Simula la recuperación de datos\r\n        // En implementación real leería de localStorage u otro sistema\r\n        return null; // No hay implementación real en este ejemplo\r\n    }\r\n}\r\n"
        }
    ]
}