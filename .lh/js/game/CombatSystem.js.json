{
    "sourceFile": "js/game/CombatSystem.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1741038271411,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1741038271411,
            "name": "Commit-0",
            "content": "/**\r\n * Sistema de combate para Cybervania\r\n * Maneja todas las mecánicas de combate por turnos\r\n */\r\nexport class CombatSystem {\r\n    constructor(uiManager) {\r\n        this.uiManager = uiManager;\r\n        this.player = null;\r\n        this.enemy = null;\r\n        this.turn = 'player'; // player, enemy, none\r\n        this.isActive = false;\r\n        this.enemyDatabase = this.initEnemyDatabase();\r\n    }\r\n    \r\n    /**\r\n     * Inicializa la base de datos de enemigos\r\n     */\r\n    initEnemyDatabase() {\r\n        return {\r\n            \"espectro_cibernetico\": {\r\n                name: \"Espectro Cibernético\",\r\n                health: 80,\r\n                attack: 8,\r\n                defense: 3,\r\n                speed: 5,\r\n                exp: 25,\r\n                credits: 75,\r\n                sprite: \"cyber_ghoul.png\",\r\n                abilities: [\"basic_attack\", \"energy_drain\"],\r\n                drops: [\"health_potion\", \"data_fragment\"],\r\n                description: \"Una entidad digital que habita en sistemas antiguos. Se alimenta de energía residual.\"\r\n            },\r\n            \"dron_centinela\": {\r\n                name: \"Dron Centinela\",\r\n                health: 60,\r\n                attack: 12,\r\n                defense: 2,\r\n                speed: 8,\r\n                exp: 30,\r\n                credits: 85,\r\n                sprite: \"drone_sentinel.png\",\r\n                abilities: [\"basic_attack\", \"double_shot\"],\r\n                drops: [\"emp_grenade\", \"energy_cell\"],\r\n                description: \"Unidad de vigilancia autónoma. Sus sensores deteriorados lo hacen atacar indiscriminadamente.\"\r\n            },\r\n            \"cazador_digital\": {\r\n                name: \"Cazador Digital\",\r\n                health: 100,\r\n                attack: 7,\r\n                defense: 5,\r\n                speed: 4,\r\n                exp: 35,\r\n                credits: 90,\r\n                sprite: \"digital_hunter.png\",\r\n                abilities: [\"basic_attack\", \"defensive_stance\"],\r\n                drops: [\"neural_stimulant\", \"reinforced_armor\"],\r\n                description: \"Programa de seguridad avanzado. Se especializa en detectar y neutralizar intrusiones no autorizadas.\"\r\n            }\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Inicia un combate con un enemigo específico o aleatorio\r\n     */\r\n    startCombat(player, enemyId = null) {\r\n        this.player = player;\r\n        \r\n        // Seleccionar enemigo\r\n        if (enemyId && this.enemyDatabase[enemyId]) {\r\n            // Usar enemigo específico\r\n            this.enemy = this.createEnemyFromTemplate(this.enemyDatabase[enemyId]);\r\n        } else {\r\n            // Usar enemigo aleatorio\r\n            this.enemy = this.generateRandomEnemy();\r\n        }\r\n        \r\n        // Ajustar enemigo según nivel del jugador\r\n        this.scaleEnemyToPlayerLevel();\r\n        \r\n        // Inicializar combate\r\n        this.turn = 'player';\r\n        this.isActive = true;\r\n        \r\n        // Notificar a la UI\r\n        if (this.uiManager) {\r\n            this.uiManager.updateCombatUI(this.player, this.enemy);\r\n            this.uiManager.addMessage(`¡Un ${this.enemy.name} aparece!`);\r\n        }\r\n        \r\n        return {\r\n            player: this.player,\r\n            enemy: this.enemy\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Crea una instancia de enemigo desde una plantilla\r\n     */\r\n    createEnemyFromTemplate(template) {\r\n        return {\r\n            name: template.name,\r\n            maxHealth: template.health,\r\n            health: template.health,\r\n            attack: template.attack,\r\n            defense: template.defense,\r\n            speed: template.speed,\r\n            exp: template.exp,\r\n            credits: template.credits,\r\n            sprite: template.sprite,\r\n            abilities: [...template.abilities],\r\n            drops: [...template.drops],\r\n            isStunned: false,\r\n            description: template.description\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Genera un enemigo aleatorio\r\n     */\r\n    generateRandomEnemy() {\r\n        const enemyKeys = Object.keys(this.enemyDatabase);\r\n        const randomKey = enemyKeys[Math.floor(Math.random() * enemyKeys.length)];\r\n        return this.createEnemyFromTemplate(this.enemyDatabase[randomKey]);\r\n    }\r\n    \r\n    /**\r\n     * Ajusta las estadísticas del enemigo según el nivel del jugador\r\n     */\r\n    scaleEnemyToPlayerLevel() {\r\n        if (!this.player || !this.enemy) return;\r\n        \r\n        const levelFactor = 1 + (this.player.level - 1) * 0.2;\r\n        \r\n        this.enemy.maxHealth = Math.floor(this.enemy.maxHealth * levelFactor);\r\n        this.enemy.health = this.enemy.maxHealth;\r\n        this.enemy.attack = Math.floor(this.enemy.attack * levelFactor);\r\n        this.enemy.defense = Math.floor(this.enemy.defense * levelFactor);\r\n        this.enemy.exp = Math.floor(this.enemy.exp * levelFactor);\r\n        this.enemy.credits = Math.floor(this.enemy.credits * levelFactor);\r\n    }\r\n    \r\n    /**\r\n     * El jugador realiza un ataque básico\r\n     */\r\n    playerAttack() {\r\n        if (this.turn !== 'player' || !this.isActive) return null;\r\n        \r\n        // Calcular daño\r\n        const damage = Math.max(1, this.player.attack - this.enemy.defense);\r\n        this.enemy.health = Math.max(0, this.enemy.health - damage);\r\n        \r\n        const result = {\r\n            action: 'attack',\r\n            actor: 'player',\r\n            target: 'enemy',\r\n            damage: damage,\r\n            enemyDefeated: this.enemy.health <= 0\r\n        };\r\n        \r\n        // Verificar si el enemigo ha sido derrotado\r\n        if (this.enemy.health <= 0) {\r\n            this.isActive = false;\r\n            result.rewards = this.calculateRewards();\r\n        } else {\r\n            // Siguiente turno\r\n            this.turn = 'enemy';\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * El jugador usa una habilidad\r\n     */\r\n    playerUseSkill(skillId) {\r\n        if (this.turn !== 'player' || !this.isActive) return null;\r\n        \r\n        const skill = this.getSkillById(skillId);\r\n        if (!skill) return null;\r\n        \r\n        // Verificar coste de energía\r\n        if (this.player.energy < skill.energyCost) {\r\n            return { error: 'energy', message: 'No tienes suficiente energía' };\r\n        }\r\n        \r\n        // Consumir energía\r\n        this.player.energy -= skill.energyCost;\r\n        \r\n        let damage = 0;\r\n        let healing = 0;\r\n        let effects = [];\r\n        \r\n        // Aplicar efectos según la habilidad\r\n        switch (skillId) {\r\n            case 'critical_strike':\r\n                damage = Math.floor(this.player.attack * 1.5);\r\n                this.enemy.health = Math.max(0, this.enemy.health - damage);\r\n                break;\r\n                \r\n            case 'cyber_shield':\r\n                effects.push({\r\n                    type: 'defense_up',\r\n                    value: 3,\r\n                    duration: 3\r\n                });\r\n                this.player.defense += 3;\r\n                this.player.activeEffects = this.player.activeEffects || [];\r\n                this.player.activeEffects.push({\r\n                    id: 'cyber_shield',\r\n                    remaining: 3,\r\n                    onExpire: () => { this.player.defense -= 3; }\r\n                });\r\n                break;\r\n                \r\n            case 'neural_interference':\r\n                damage = Math.floor(this.player.attack * 0.8);\r\n                this.enemy.health = Math.max(0, this.enemy.health - damage);\r\n                this.enemy.isStunned = true;\r\n                effects.push({\r\n                    type: 'stun',\r\n                    duration: 1\r\n                });\r\n                break;\r\n                \r\n            case 'energy_restoration':\r\n                healing = Math.floor(this.player.maxHealth * 0.2);\r\n                this.player.health = Math.min(this.player.maxHealth, this.player.health + healing);\r\n                break;\r\n        }\r\n        \r\n        const result = {\r\n            action: 'skill',\r\n            actor: 'player',\r\n            skillId,\r\n            skillName: skill.name,\r\n            target: skill.target,\r\n            damage,\r\n            healing,\r\n            effects,\r\n            enemyDefeated: this.enemy.health <= 0\r\n        };\r\n        \r\n        // Verificar si el enemigo ha sido derrotado\r\n        if (this.enemy.health <= 0) {\r\n            this.isActive = false;\r\n            result.rewards = this.calculateRewards();\r\n        } else {\r\n            // Siguiente turno\r\n            this.turn = 'enemy';\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * El jugador usa un objeto\r\n     */\r\n    playerUseItem(itemId) {\r\n        if (this.turn !== 'player' || !this.isActive) return null;\r\n        \r\n        // Buscar item en inventario\r\n        const itemIndex = this.player.inventory.findIndex(item => item.id === itemId);\r\n        if (itemIndex === -1) return null;\r\n        \r\n        const item = this.player.inventory[itemIndex];\r\n        let effect = 0;\r\n        \r\n        // Aplicar efecto según tipo de ítem\r\n        switch (item.type) {\r\n            case 'heal':\r\n                effect = Math.min(item.value, this.player.maxHealth - this.player.health);\r\n                this.player.health += effect;\r\n                break;\r\n                \r\n            case 'energy':\r\n                effect = Math.min(item.value, this.player.maxEnergy - this.player.energy);\r\n                this.player.energy += effect;\r\n                break;\r\n                \r\n            case 'damage':\r\n                effect = Math.max(1, item.value - this.enemy.defense);\r\n                this.enemy.health = Math.max(0, this.enemy.health - effect);\r\n                break;\r\n                \r\n            default:\r\n                return { error: 'invalid_item', message: 'Este objeto no se puede usar en combate' };\r\n        }\r\n        \r\n        // Eliminar objeto del inventario\r\n        this.player.inventory.splice(itemIndex, 1);\r\n        \r\n        const result = {\r\n            action: 'item',\r\n            actor: 'player',\r\n            itemName: item.name,\r\n            itemType: item.type,\r\n            effect,\r\n            enemyDefeated: this.enemy.health <= 0\r\n        };\r\n        \r\n        // Verificar si el enemigo ha sido derrotado\r\n        if (this.enemy.health <= 0) {\r\n            this.isActive = false;\r\n            result.rewards = this.calculateRewards();\r\n        } else {\r\n            // Siguiente turno\r\n            this.turn = 'enemy';\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * El jugador se defiende\r\n     */\r\n    playerDefend() {\r\n        if (this.turn !== 'player' || !this.isActive) return null;\r\n        \r\n        // Aumentar defensa temporalmente\r\n        const defenseBonus = Math.floor(this.player.defense * 0.5);\r\n        this.player.defense += defenseBonus;\r\n        this.player.defending = true;\r\n        \r\n        const result = {\r\n            action: 'defend',\r\n            actor: 'player',\r\n            defenseBonus\r\n        };\r\n        \r\n        // Siguiente turno\r\n        this.turn = 'enemy';\r\n        \r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * El enemigo realiza su turno\r\n     */\r\n    enemyTurn() {\r\n        if (this.turn !== 'enemy' || !this.isActive) return null;\r\n        \r\n        // Verificar si el enemigo está aturdido\r\n        if (this.enemy.isStunned) {\r\n            this.enemy.isStunned = false;\r\n            \r\n            // Siguiente turno\r\n            this.turn = 'player';\r\n            \r\n            return {\r\n                action: 'stunned',\r\n                actor: 'enemy'\r\n            };\r\n        }\r\n        \r\n        // Elegir acción del enemigo\r\n        const action = this.selectEnemyAction();\r\n        let result = null;\r\n        \r\n        switch (action) {\r\n            case 'basic_attack':\r\n                result = this.enemyBasicAttack();\r\n                break;\r\n                \r\n            case 'energy_drain':\r\n                result = this.enemyEnergyDrain();\r\n                break;\r\n                \r\n            case 'double_shot':\r\n                result = this.enemyDoubleShot();\r\n                break;\r\n                \r\n            case 'defensive_stance':\r\n                result = this.enemyDefensiveStance();\r\n                break;\r\n        }\r\n        \r\n        // Comprobar si el jugador está defendiéndose\r\n        if (this.player.defending) {\r\n            const defenseBonus = Math.floor(this.player.defense * 0.5 / 1.5);\r\n            this.player.defense -= defenseBonus;\r\n            this.player.defending = false;\r\n        }\r\n        \r\n        // Verificar si el jugador ha sido derrotado\r\n        if (this.player.health <= 0) {\r\n            this.isActive = false;\r\n            result.playerDefeated = true;\r\n        } else {\r\n            // Siguiente turno\r\n            this.turn = 'player';\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * Enemigo realiza ataque básico\r\n     */\r\n    enemyBasicAttack() {\r\n        const damage = Math.max(1, this.enemy.attack - this.player.defense);\r\n        this.player.health = Math.max(0, this.player.health - damage);\r\n        \r\n        return {\r\n            action: 'attack',\r\n            actor: 'enemy',\r\n            target: 'player',\r\n            damage\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Enemigo realiza drenaje de energía\r\n     */\r\n    enemyEnergyDrain() {\r\n        const damage = Math.max(1, Math.floor(this.enemy.attack * 0.7) - this.player.defense);\r\n        const energyD"
        }
    ]
}