{
    "sourceFile": "js/ui/MenuEffects.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1741026786740,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1741027044718,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,8 +34,16 @@\n         // Configurar atributo data-text para el efecto de título\r\n         const title = document.querySelector('.title-container h1');\r\n         if (title) {\r\n             title.setAttribute('data-text', title.textContent);\r\n+            \r\n+            // Ocasionalmente aplicar efecto de distorsión severa\r\n+            setInterval(() => {\r\n+                // Probabilidad del 15% de tener un glitch severo\r\n+                if (Math.random() < 0.15) {\r\n+                    this.applyTitleGlitch(title);\r\n+                }\r\n+            }, 4000);\r\n         }\r\n     }\r\n     \r\n     applyRandomGlitch(element) {\r\n@@ -59,8 +67,58 @@\n             }, 100);\r\n         }\r\n     }\r\n     \r\n+    applyTitleGlitch(titleElement) {\r\n+        // Guardar texto original\r\n+        const originalText = titleElement.textContent;\r\n+        \r\n+        // Crear versión distorsionada del texto\r\n+        let glitchedText = '';\r\n+        const glitchChars = '!@#$%^&*()_-+=<>?/';\r\n+        \r\n+        // 20% de probabilidad de un glitch muy severo (todo caracteres extraños)\r\n+        if (Math.random() < 0.2) {\r\n+            for (let i = 0; i < originalText.length; i++) {\r\n+                glitchedText += glitchChars.charAt(Math.floor(Math.random() * glitchChars.length));\r\n+            }\r\n+            titleElement.textContent = glitchedText;\r\n+            \r\n+            // Desplazar ligeramente la posición\r\n+            titleElement.style.transform = `translate(${(Math.random() * 6) - 3}px, ${(Math.random() * 6) - 3}px)`;\r\n+            \r\n+            // Restaurar después de un tiempo muy breve\r\n+            setTimeout(() => {\r\n+                titleElement.textContent = originalText;\r\n+                titleElement.style.transform = '';\r\n+            }, 100);\r\n+        } \r\n+        // Para glitches menos severos, reemplazamos solo algunos caracteres\r\n+        else {\r\n+            for (let i = 0; i < originalText.length; i++) {\r\n+                // 30% de probabilidad de cambiar cada carácter\r\n+                if (Math.random() < 0.3) {\r\n+                    glitchedText += glitchChars.charAt(Math.floor(Math.random() * glitchChars.length));\r\n+                } else {\r\n+                    glitchedText += originalText.charAt(i);\r\n+                }\r\n+            }\r\n+            \r\n+            titleElement.textContent = glitchedText;\r\n+            \r\n+            // Aplicar animación CSS de distorsión\r\n+            titleElement.style.animation = 'distortion 0.2s linear';\r\n+            \r\n+            // Restaurar después de unos milisegundos\r\n+            setTimeout(() => {\r\n+                titleElement.textContent = originalText;\r\n+                setTimeout(() => {\r\n+                    titleElement.style.animation = '';\r\n+                }, 200);\r\n+            }, 150);\r\n+        }\r\n+    }\r\n+    \r\n     removeGlitch(element) {\r\n         clearInterval(this.glitchInterval);\r\n         element.style.transform = '';\r\n     }\r\n"
                },
                {
                    "date": 1741029598426,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,183 +1,207 @@\n /**\r\n- * Efectos visuales adicionales para el menú gótico-cyberpunk de Cybervania\r\n+ * Clase para gestionar efectos visuales del menú principal\r\n  */\r\n export class MenuEffects {\r\n-    constructor(menuContainer) {\r\n-        this.container = document.getElementById(menuContainer);\r\n-        this.transitionElement = null;\r\n-        this.glitchInterval = null;\r\n-        this.initialize();\r\n+    constructor(containerId) {\r\n+        this.container = document.getElementById(containerId);\r\n+        this.effectsEnabled = true;\r\n+        \r\n+        // Inicializar propiedades\r\n+        this.qualityLevel = 'high'; // low, medium, high\r\n+        this.particleCount = 15;\r\n+        this.mistElements = [];\r\n+        \r\n+        // Aplicar efectos iniciales\r\n+        this.initEffects();\r\n     }\r\n     \r\n-    initialize() {\r\n-        this.createTransitionLayer();\r\n-        this.setupGlitchEffects();\r\n-        this.setupTitleEffect();\r\n+    initEffects() {\r\n+        // Iniciar con efecto de inicio si es compatible con el navegador\r\n+        if (window.CSS && CSS.supports('animation-name', 'fadeIn')) {\r\n+            this.applyStartupEffect();\r\n+        }\r\n     }\r\n     \r\n-    createTransitionLayer() {\r\n-        // Crear capa para transiciones\r\n-        this.transitionElement = document.createElement('div');\r\n-        this.transitionElement.className = 'transition-glitch';\r\n-        document.body.appendChild(this.transitionElement);\r\n+    /**\r\n+     * Aplica efecto de inicio al cargar el menú\r\n+     */\r\n+    applyStartupEffect() {\r\n+        const glitchOverlay = document.createElement('div');\r\n+        glitchOverlay.className = 'transition-glitch';\r\n+        this.container.appendChild(glitchOverlay);\r\n+        \r\n+        // Activar transición\r\n+        setTimeout(() => {\r\n+            this.container.classList.add('transition-active');\r\n+            \r\n+            // Limpiar después de la animación\r\n+            setTimeout(() => {\r\n+                this.container.classList.remove('transition-active');\r\n+                glitchOverlay.remove();\r\n+            }, 800);\r\n+        }, 100);\r\n     }\r\n     \r\n-    setupGlitchEffects() {\r\n-        // Aplicar efectos de glitch aleatorios a elementos\r\n-        document.querySelectorAll('.menu-item, button, .title-container h1').forEach(el => {\r\n-            el.addEventListener('mouseenter', () => this.applyRandomGlitch(el));\r\n-            el.addEventListener('mouseleave', () => this.removeGlitch(el));\r\n-        });\r\n+    /**\r\n+     * Crea/actualiza elementos de niebla según calidad visual\r\n+     */\r\n+    updateMistEffects(quality = 'high') {\r\n+        // Limpiar niebla existente\r\n+        const mistLayer = this.container.querySelector('.mist-layer');\r\n+        if (!mistLayer) return;\r\n+        \r\n+        mistLayer.innerHTML = '';\r\n+        \r\n+        // Ajustar cantidad y calidad según nivel\r\n+        let count, opacity, size;\r\n+        \r\n+        switch (quality) {\r\n+            case 'low':\r\n+                count = 3;\r\n+                opacity = 0.1;\r\n+                size = 200;\r\n+                break;\r\n+                \r\n+            case 'medium':\r\n+                count = 7;\r\n+                opacity = 0.2;\r\n+                size = 250;\r\n+                break;\r\n+                \r\n+            case 'high':\r\n+            default:\r\n+                count = 12;\r\n+                opacity = 0.3;\r\n+                size = 300;\r\n+                break;\r\n+        }\r\n+        \r\n+        // Crear nuevos elementos de niebla\r\n+        for (let i = 0; i < count; i++) {\r\n+            const mistElement = document.createElement('div');\r\n+            mistElement.className = 'mist-element';\r\n+            mistElement.style.opacity = (Math.random() * opacity + 0.05).toString();\r\n+            mistElement.style.left = (Math.random() * 100) + '%';\r\n+            mistElement.style.top = (Math.random() * 100) + '%';\r\n+            mistElement.style.width = size + 'px';\r\n+            mistElement.style.height = size + 'px';\r\n+            mistElement.style.animationDuration = (Math.random() * 15 + 15) + 's';\r\n+            mistElement.style.animationDelay = (Math.random() * 5) + 's';\r\n+            mistLayer.appendChild(mistElement);\r\n+            this.mistElements.push(mistElement);\r\n+        }\r\n+        \r\n+        // Guardar nivel actual\r\n+        this.qualityLevel = quality;\r\n     }\r\n     \r\n-    setupTitleEffect() {\r\n-        // Configurar atributo data-text para el efecto de título\r\n-        const title = document.querySelector('.title-container h1');\r\n-        if (title) {\r\n-            title.setAttribute('data-text', title.textContent);\r\n-            \r\n-            // Ocasionalmente aplicar efecto de distorsión severa\r\n-            setInterval(() => {\r\n-                // Probabilidad del 15% de tener un glitch severo\r\n-                if (Math.random() < 0.15) {\r\n-                    this.applyTitleGlitch(title);\r\n-                }\r\n-            }, 4000);\r\n-        }\r\n+    /**\r\n+     * Actualiza la intensidad de los efectos visuales\r\n+     */\r\n+    updateEffectsIntensity(intensity) {\r\n+        document.documentElement.style.setProperty('--effect-intensity', intensity);\r\n     }\r\n     \r\n-    applyRandomGlitch(element) {\r\n-        // Probabilidad baja de aplicar efecto glitch\r\n-        if (Math.random() < 0.3) {\r\n-            this.glitchInterval = setInterval(() => {\r\n-                // Aplicar distorsión visual sutil\r\n-                const intensity = Math.random() * 2 + 1;\r\n-                const xOffset = (Math.random() - 0.5) * intensity;\r\n-                const yOffset = (Math.random() - 0.5) * intensity;\r\n-                \r\n-                element.style.transform = `translate(${xOffset}px, ${yOffset}px)`;\r\n-                \r\n-                // Cambiar color brevemente\r\n-                if (Math.random() < 0.2) {\r\n-                    element.style.color = 'rgba(255, 50, 150, 0.9)';\r\n-                    setTimeout(() => {\r\n-                        element.style.color = '';\r\n-                    }, 50);\r\n-                }\r\n-            }, 100);\r\n+    /**\r\n+     * Aplica modo de alto contraste para accesibilidad\r\n+     */\r\n+    toggleHighContrast(enabled) {\r\n+        if (enabled) {\r\n+            document.body.classList.add('high-contrast');\r\n+        } else {\r\n+            document.body.classList.remove('high-contrast');\r\n         }\r\n     }\r\n     \r\n-    applyTitleGlitch(titleElement) {\r\n-        // Guardar texto original\r\n-        const originalText = titleElement.textContent;\r\n+    /**\r\n+     * Aplica efecto de interferencia de señal a los elementos\r\n+     */\r\n+    simulateSignalInterference(duration = 500) {\r\n+        const title = this.container.querySelector('.title-container');\r\n+        if (!title) return;\r\n         \r\n-        // Crear versión distorsionada del texto\r\n-        let glitchedText = '';\r\n-        const glitchChars = '!@#$%^&*()_-+=<>?/';\r\n+        // Añadir clase para efecto\r\n+        title.classList.add('signal-interference');\r\n         \r\n-        // 20% de probabilidad de un glitch muy severo (todo caracteres extraños)\r\n-        if (Math.random() < 0.2) {\r\n-            for (let i = 0; i < originalText.length; i++) {\r\n-                glitchedText += glitchChars.charAt(Math.floor(Math.random() * glitchChars.length));\r\n-            }\r\n-            titleElement.textContent = glitchedText;\r\n+        // Aplicar distorsión a textos\r\n+        const texts = title.querySelectorAll('h1, h2');\r\n+        texts.forEach(text => {\r\n+            const originalText = text.textContent;\r\n+            const glitchTextArr = originalText.split('');\r\n             \r\n-            // Desplazar ligeramente la posición\r\n-            titleElement.style.transform = `translate(${(Math.random() * 6) - 3}px, ${(Math.random() * 6) - 3}px)`;\r\n+            // Animar distorsión\r\n+            const glitchInterval = setInterval(() => {\r\n+                // Reemplazar algunos caracteres aleatoriamente\r\n+                const randomIndex = Math.floor(Math.random() * glitchTextArr.length);\r\n+                const randomChar = this.getRandomGlitchChar();\r\n+                \r\n+                glitchTextArr[randomIndex] = Math.random() > 0.5 ? randomChar : originalText[randomIndex];\r\n+                text.textContent = glitchTextArr.join('');\r\n+            }, 50);\r\n             \r\n-            // Restaurar después de un tiempo muy breve\r\n+            // Restaurar texto original después del efecto\r\n             setTimeout(() => {\r\n-                titleElement.textContent = originalText;\r\n-                titleElement.style.transform = '';\r\n-            }, 100);\r\n-        } \r\n-        // Para glitches menos severos, reemplazamos solo algunos caracteres\r\n-        else {\r\n-            for (let i = 0; i < originalText.length; i++) {\r\n-                // 30% de probabilidad de cambiar cada carácter\r\n-                if (Math.random() < 0.3) {\r\n-                    glitchedText += glitchChars.charAt(Math.floor(Math.random() * glitchChars.length));\r\n-                } else {\r\n-                    glitchedText += originalText.charAt(i);\r\n-                }\r\n-            }\r\n-            \r\n-            titleElement.textContent = glitchedText;\r\n-            \r\n-            // Aplicar animación CSS de distorsión\r\n-            titleElement.style.animation = 'distortion 0.2s linear';\r\n-            \r\n-            // Restaurar después de unos milisegundos\r\n-            setTimeout(() => {\r\n-                titleElement.textContent = originalText;\r\n-                setTimeout(() => {\r\n-                    titleElement.style.animation = '';\r\n-                }, 200);\r\n-            }, 150);\r\n-        }\r\n+                clearInterval(glitchInterval);\r\n+                text.textContent = originalText;\r\n+                title.classList.remove('signal-interference');\r\n+            }, duration);\r\n+        });\r\n     }\r\n     \r\n-    removeGlitch(element) {\r\n-        clearInterval(this.glitchInterval);\r\n-        element.style.transform = '';\r\n+    /**\r\n+     * Devuelve un carácter aleatorio para efectos glitch\r\n+     */\r\n+    getRandomGlitchChar() {\r\n+        const chars = '!@#$%^&*()_+-=[]{}|;:,.<>?/\\\\¿¡§±æøðłßØμΣΔφΘλΠ©®';\r\n+        return chars.charAt(Math.floor(Math.random() * chars.length));\r\n     }\r\n     \r\n-    playTransition() {\r\n-        document.body.classList.add('transition-active');\r\n+    /**\r\n+     * Activa un relámpago ambiental aleatorio\r\n+     */\r\n+    triggerLightning() {\r\n+        const lightningDiv = document.createElement('div');\r\n+        lightningDiv.className = 'ambient-lightning';\r\n+        document.body.appendChild(lightningDiv);\r\n         \r\n         setTimeout(() => {\r\n-            document.body.classList.remove('transition-active');\r\n-        }, 600);\r\n+            lightningDiv.classList.add('flash');\r\n+            \r\n+            // Eliminar después de la animación\r\n+            setTimeout(() => {\r\n+                lightningDiv.remove();\r\n+            }, 1500);\r\n+        }, 100);\r\n     }\r\n     \r\n-    // Método para simular problema de recepción como en viejas TVs\r\n-    simulateSignalInterference(duration = 500) {\r\n-        const interference = document.createElement('div');\r\n-        interference.style.cssText = `\r\n-            position: fixed;\r\n-            top: 0;\r\n-            left: 0;\r\n-            width: 100%;\r\n-            height: 100%;\r\n-            background: repeating-linear-gradient(\r\n-                0deg,\r\n-                rgba(0, 0, 0, 0.1),\r\n-                rgba(0, 0, 0, 0.1) 1px,\r\n-                rgba(255, 255, 255, 0.1) 1px,\r\n-                rgba(255, 255, 255, 0.1) 2px\r\n-            );\r\n-            pointer-events: none;\r\n-            z-index: 9999;\r\n-            opacity: 0;\r\n-            animation: interference 0.5s ease;\r\n-        `;\r\n+    /**\r\n+     * Activa la viñeta oscura pulsante\r\n+     */\r\n+    pulseVignette() {\r\n+        const vignette = document.querySelector('.dark-vignette');\r\n+        if (vignette) {\r\n+            vignette.classList.add('pulse');\r\n+            setTimeout(() => {\r\n+                vignette.classList.remove('pulse');\r\n+            }, 3000);\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Establece el FPS objetivo para el menú\r\n+     */\r\n+    setTargetFPS(fps) {\r\n+        // En una implementación real, ajustaríamos los timers y animaciones\r\n+        // Para este ejemplo, solo imprimimos el valor\r\n+        console.log(`FPS objetivo establecido a: ${fps}`);\r\n         \r\n-        document.body.appendChild(interference);\r\n-        \r\n-        // Crear keyframe dinámico\r\n-        const style = document.createElement('style');\r\n-        style.textContent = `\r\n-            @keyframes interference {\r\n-                0% { opacity: 0; }\r\n-                10% { opacity: 0.8; }\r\n-                20% { opacity: 0.2; }\r\n-                30% { opacity: 0.7; }\r\n-                40% { opacity: 0.3; }\r\n-                50% { opacity: 0.9; }\r\n-                60% { opacity: 0.2; }\r\n-                70% { opacity: 0.7; }\r\n-                80% { opacity: 0.1; }\r\n-                90% { opacity: 0.5; }\r\n-                100% { opacity: 0; }\r\n-            }\r\n-        `;\r\n-        document.head.appendChild(style);\r\n-        \r\n-        // Eliminar después de la animación\r\n-        setTimeout(() => {\r\n-            interference.remove();\r\n-            style.remove();\r\n-        }, duration);\r\n+        // Si es un valor bajo, podemos deshabilitar algunas animaciones\r\n+        if (fps <= 30) {\r\n+            document.body.classList.add('low-performance');\r\n+            this.updateEffectsIntensity(0.5); // Reducir intensidad\r\n+        } else {\r\n+            document.body.classList.remove('low-performance');\r\n+            this.updateEffectsIntensity(1.0); // Restaurar intensidad\r\n+        }\r\n     }\r\n }\r\n"
                },
                {
                    "date": 1741033118438,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,162 @@\n+/**\r\n+ * Efectos visuales para el menú con estilo de 16 bits\r\n+ */\r\n+export class MenuEffects {\r\n+    constructor(containerId) {\r\n+        this.container = document.getElementById(containerId);\r\n+        this.effectsIntensity = 1.0;\r\n+        this.highContrastMode = false;\r\n+        this.targetFPS = 60;\r\n+        \r\n+        // Píxeles para el fondo\r\n+        this.createPixelBackground();\r\n+    }\r\n+    \r\n+    /**\r\n+     * Crear un fondo con \"píxeles\" animados\r\n+     */\r\n+    createPixelBackground() {\r\n+        // Limpiar píxeles anteriores si existen\r\n+        const existingPixels = document.querySelector('.pixel-grid');\r\n+        if (existingPixels) {\r\n+            existingPixels.remove();\r\n+        }\r\n+        \r\n+        // Crear contenedor para los píxeles\r\n+        const pixelGrid = document.createElement('div');\r\n+        pixelGrid.className = 'pixel-grid';\r\n+        pixelGrid.style.cssText = `\r\n+            position: absolute;\r\n+            top: 0;\r\n+            left: 0;\r\n+            width: 100%;\r\n+            height: 100%;\r\n+            z-index: 1;\r\n+            pointer-events: none;\r\n+            opacity: 0.3;\r\n+        `;\r\n+        \r\n+        // Añadir píxeles aleatorios animados\r\n+        const pixelCount = 15; // Limitado para mejor rendimiento\r\n+        for (let i = 0; i < pixelCount; i++) {\r\n+            const pixel = document.createElement('div');\r\n+            const size = 8; // Tamaño de cada pixel en px\r\n+            const posX = Math.random() * 100;\r\n+            const posY = Math.random() * 100;\r\n+            \r\n+            // Colores SNES\r\n+            const colors = [\r\n+                '#b13e53', '#ef7d57', '#ffcd75', \r\n+                '#a7f070', '#38b764', '#3b5dc9', \r\n+                '#41a6f6', '#73eff7'\r\n+            ];\r\n+            \r\n+            const color = colors[Math.floor(Math.random() * colors.length)];\r\n+            \r\n+            pixel.style.cssText = `\r\n+                position: absolute;\r\n+                width: ${size}px;\r\n+                height: ${size}px;\r\n+                background-color: ${color};\r\n+                left: ${posX}%;\r\n+                top: ${posY}%;\r\n+                opacity: ${Math.random() * 0.4 + 0.1};\r\n+                animation: pixel-flicker ${Math.random() * 2 + 2}s infinite step-end;\r\n+                box-shadow: 0 0 ${size}px ${color};\r\n+            `;\r\n+            \r\n+            pixelGrid.appendChild(pixel);\r\n+        }\r\n+        \r\n+        // Añadir la cuadrícula al contenedor\r\n+        this.container.appendChild(pixelGrid);\r\n+        \r\n+        // Añadir los keyframes para la animación\r\n+        const style = document.createElement('style');\r\n+        style.innerHTML = `\r\n+            @keyframes pixel-flicker {\r\n+                0%, 100% { opacity: 0.1; }\r\n+                50%, 70% { opacity: 0.5; }\r\n+            }\r\n+        `;\r\n+        document.head.appendChild(style);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Simula una interferencia de señal temporal\r\n+     */\r\n+    simulateSignalInterference() {\r\n+        // No aplicar con calidad baja\r\n+        if (this.effectsIntensity < 0.3) return;\r\n+        \r\n+        const glitchEffect = document.createElement('div');\r\n+        glitchEffect.className = 'signal-interference';\r\n+        glitchEffect.style.cssText = `\r\n+            position: fixed;\r\n+            top: 0;\r\n+            left: 0;\r\n+            width: 100%;\r\n+            height: 100%;\r\n+            background: linear-gradient(transparent, rgba(0,0,0,0.4) 50%, transparent 51%, transparent);\r\n+            background-size: 100% 8px;\r\n+            z-index: 1000;\r\n+            pointer-events: none;\r\n+            opacity: 0.7;\r\n+            animation: scan-line 0.1s linear;\r\n+        `;\r\n+        \r\n+        document.body.appendChild(glitchEffect);\r\n+        \r\n+        setTimeout(() => {\r\n+            glitchEffect.style.opacity = '0';\r\n+            setTimeout(() => {\r\n+                glitchEffect.remove();\r\n+            }, 100);\r\n+        }, 200);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Actualiza la intensidad de los efectos según la calidad visual\r\n+     */\r\n+    updateEffectsIntensity(intensity) {\r\n+        this.effectsIntensity = intensity;\r\n+        document.documentElement.style.setProperty('--effect-intensity', intensity.toString());\r\n+        \r\n+        // Actualizar cantidad de partículas según intensidad\r\n+        this.createPixelBackground();\r\n+    }\r\n+    \r\n+    /**\r\n+     * Actualiza los efectos de niebla según el nivel de calidad\r\n+     */\r\n+    updateMistEffects(quality) {\r\n+        // No hay niebla en el estilo 16 bits, pero podemos ajustar los píxeles\r\n+        if (quality === 'low') {\r\n+            this.updateEffectsIntensity(0.3);\r\n+        } else if (quality === 'medium') {\r\n+            this.updateEffectsIntensity(0.6);\r\n+        } else {\r\n+            this.updateEffectsIntensity(1.0);\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Establece el modo de alto contraste\r\n+     */\r\n+    toggleHighContrast(enabled) {\r\n+        this.highContrastMode = enabled;\r\n+        if (enabled) {\r\n+            document.body.classList.add('high-contrast');\r\n+        } else {\r\n+            document.body.classList.remove('high-contrast');\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Establece el límite de FPS objetivo\r\n+     */\r\n+    setTargetFPS(fps) {\r\n+        this.targetFPS = fps;\r\n+        // En este tipo de estilo no necesitamos limitar FPS\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1741033154929,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,162 @@\n+/**\r\n+ * Efectos visuales para el menú con estilo de 16 bits\r\n+ */\r\n+export class MenuEffects {\r\n+    constructor(containerId) {\r\n+        this.container = document.getElementById(containerId);\r\n+        this.effectsIntensity = 1.0;\r\n+        this.highContrastMode = false;\r\n+        this.targetFPS = 60;\r\n+        \r\n+        // Píxeles para el fondo\r\n+        this.createPixelBackground();\r\n+    }\r\n+    \r\n+    /**\r\n+     * Crear un fondo con \"píxeles\" animados\r\n+     */\r\n+    createPixelBackground() {\r\n+        // Limpiar píxeles anteriores si existen\r\n+        const existingPixels = document.querySelector('.pixel-grid');\r\n+        if (existingPixels) {\r\n+            existingPixels.remove();\r\n+        }\r\n+        \r\n+        // Crear contenedor para los píxeles\r\n+        const pixelGrid = document.createElement('div');\r\n+        pixelGrid.className = 'pixel-grid';\r\n+        pixelGrid.style.cssText = `\r\n+            position: absolute;\r\n+            top: 0;\r\n+            left: 0;\r\n+            width: 100%;\r\n+            height: 100%;\r\n+            z-index: 1;\r\n+            pointer-events: none;\r\n+            opacity: 0.3;\r\n+        `;\r\n+        \r\n+        // Añadir píxeles aleatorios animados\r\n+        const pixelCount = 15; // Limitado para mejor rendimiento\r\n+        for (let i = 0; i < pixelCount; i++) {\r\n+            const pixel = document.createElement('div');\r\n+            const size = 8; // Tamaño de cada pixel en px\r\n+            const posX = Math.random() * 100;\r\n+            const posY = Math.random() * 100;\r\n+            \r\n+            // Colores SNES\r\n+            const colors = [\r\n+                '#b13e53', '#ef7d57', '#ffcd75', \r\n+                '#a7f070', '#38b764', '#3b5dc9', \r\n+                '#41a6f6', '#73eff7'\r\n+            ];\r\n+            \r\n+            const color = colors[Math.floor(Math.random() * colors.length)];\r\n+            \r\n+            pixel.style.cssText = `\r\n+                position: absolute;\r\n+                width: ${size}px;\r\n+                height: ${size}px;\r\n+                background-color: ${color};\r\n+                left: ${posX}%;\r\n+                top: ${posY}%;\r\n+                opacity: ${Math.random() * 0.4 + 0.1};\r\n+                animation: pixel-flicker ${Math.random() * 2 + 2}s infinite step-end;\r\n+                box-shadow: 0 0 ${size}px ${color};\r\n+            `;\r\n+            \r\n+            pixelGrid.appendChild(pixel);\r\n+        }\r\n+        \r\n+        // Añadir la cuadrícula al contenedor\r\n+        this.container.appendChild(pixelGrid);\r\n+        \r\n+        // Añadir los keyframes para la animación\r\n+        const style = document.createElement('style');\r\n+        style.innerHTML = `\r\n+            @keyframes pixel-flicker {\r\n+                0%, 100% { opacity: 0.1; }\r\n+                50%, 70% { opacity: 0.5; }\r\n+            }\r\n+        `;\r\n+        document.head.appendChild(style);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Simula una interferencia de señal temporal\r\n+     */\r\n+    simulateSignalInterference() {\r\n+        // No aplicar con calidad baja\r\n+        if (this.effectsIntensity < 0.3) return;\r\n+        \r\n+        const glitchEffect = document.createElement('div');\r\n+        glitchEffect.className = 'signal-interference';\r\n+        glitchEffect.style.cssText = `\r\n+            position: fixed;\r\n+            top: 0;\r\n+            left: 0;\r\n+            width: 100%;\r\n+            height: 100%;\r\n+            background: linear-gradient(transparent, rgba(0,0,0,0.4) 50%, transparent 51%, transparent);\r\n+            background-size: 100% 8px;\r\n+            z-index: 1000;\r\n+            pointer-events: none;\r\n+            opacity: 0.7;\r\n+            animation: scan-line 0.1s linear;\r\n+        `;\r\n+        \r\n+        document.body.appendChild(glitchEffect);\r\n+        \r\n+        setTimeout(() => {\r\n+            glitchEffect.style.opacity = '0';\r\n+            setTimeout(() => {\r\n+                glitchEffect.remove();\r\n+            }, 100);\r\n+        }, 200);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Actualiza la intensidad de los efectos según la calidad visual\r\n+     */\r\n+    updateEffectsIntensity(intensity) {\r\n+        this.effectsIntensity = intensity;\r\n+        document.documentElement.style.setProperty('--effect-intensity', intensity.toString());\r\n+        \r\n+        // Actualizar cantidad de partículas según intensidad\r\n+        this.createPixelBackground();\r\n+    }\r\n+    \r\n+    /**\r\n+     * Actualiza los efectos de niebla según el nivel de calidad\r\n+     */\r\n+    updateMistEffects(quality) {\r\n+        // No hay niebla en el estilo 16 bits, pero podemos ajustar los píxeles\r\n+        if (quality === 'low') {\r\n+            this.updateEffectsIntensity(0.3);\r\n+        } else if (quality === 'medium') {\r\n+            this.updateEffectsIntensity(0.6);\r\n+        } else {\r\n+            this.updateEffectsIntensity(1.0);\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Establece el modo de alto contraste\r\n+     */\r\n+    toggleHighContrast(enabled) {\r\n+        this.highContrastMode = enabled;\r\n+        if (enabled) {\r\n+            document.body.classList.add('high-contrast');\r\n+        } else {\r\n+            document.body.classList.remove('high-contrast');\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Establece el límite de FPS objetivo\r\n+     */\r\n+    setTargetFPS(fps) {\r\n+        this.targetFPS = fps;\r\n+        // En este tipo de estilo no necesitamos limitar FPS\r\n+    }\r\n+}\r\n"
                },
                {
                    "date": 1741035027867,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n      */\r\n     initialize() {\r\n         // Crea partículas de niebla digital\r\n         this.createDigitalMist();\r\n-        const existingPixels = document.querySelector('.pixel-grid');\r\n+        \r\n         if (existingPixels) {\r\n             existingPixels.remove();\r\n         }\r\n         \r\n"
                },
                {
                    "date": 1741035035525,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,49 +18,49 @@\n         // Crea partículas de niebla digital\r\n         this.createDigitalMist();\r\n         \r\n         // Añadir efectos de resplandor a elementos\r\n-            existingPixels.remove();\r\n-        }\r\n+        this.addGlowEffects();\r\n+    }\r\n+    \r\n+    /**\r\n+     * Crea un efecto de niebla digital en el fondo\r\n+     */\r\n+    createDigitalMist() {\r\n+        // Verificar si ya existe y removerlo\r\n+        const existingMist = document.querySelector('.digital-mist');\r\n+        if (existingMist) existingMist.remove();\r\n         \r\n-        // Crear contenedor para los píxeles\r\n-        const pixelGrid = document.createElement('div');\r\n-        pixelGrid.className = 'pixel-grid';\r\n-        pixelGrid.style.cssText = `\r\n+        // Crear el contenedor de la niebla\r\n+        const mistContainer = document.createElement('div');\r\n+        mistContainer.className = 'digital-mist';\r\n+        mistContainer.style.cssText = `\r\n             position: absolute;\r\n             top: 0;\r\n             left: 0;\r\n             width: 100%;\r\n             height: 100%;\r\n+            overflow: hidden;\r\n+            pointer-events: none;\r\n             z-index: 1;\r\n-            pointer-events: none;\r\n-            opacity: 0.3;\r\n+            opacity: ${this.effectsIntensity * 0.6};\r\n         `;\r\n         \r\n-        // Añadir píxeles aleatorios animados\r\n-        const pixelCount = 15; // Limitado para mejor rendimiento\r\n-        for (let i = 0; i < pixelCount; i++) {\r\n-            const pixel = document.createElement('div');\r\n-            const size = 8; // Tamaño de cada pixel en px\r\n-            const posX = Math.random() * 100;\r\n-            const posY = Math.random() * 100;\r\n+        // Número de partículas basado en la intensidad\r\n+        const particleCount = Math.floor(30 * this.effectsIntensity);\r\n+        \r\n+        for (let i = 0; i < particleCount; i++) {\r\n+            const particle = document.createElement('div');\r\n             \r\n-            // Colores SNES\r\n+            // Propiedades aleatorias\r\n+            const size = 2 + Math.random() * 3;\r\n+            const x = Math.random() * 100;\r\n+            const y = Math.random() * 100;\r\n+            const delay = Math.random() * 5;\r\n+            const duration = 10 + Math.random() * 20;\r\n+            \r\n+            // Colores temáticos\r\n             const colors = [\r\n-                '#b13e53', '#ef7d57', '#ffcd75', \r\n-                '#a7f070', '#38b764', '#3b5dc9', \r\n-                '#41a6f6', '#73eff7'\r\n-            ];\r\n-            \r\n-            const color = colors[Math.floor(Math.random() * colors.length)];\r\n-            \r\n-            pixel.style.cssText = `\r\n-                position: absolute;\r\n-                width: ${size}px;\r\n-                height: ${size}px;\r\n-                background-color: ${color};\r\n-                left: ${posX}%;\r\n-                top: ${posY}%;\r\n                 opacity: ${Math.random() * 0.4 + 0.1};\r\n                 animation: pixel-flicker ${Math.random() * 2 + 2}s infinite step-end;\r\n                 box-shadow: 0 0 ${size}px ${color};\r\n             `;\r\n"
                }
            ],
            "date": 1741026786740,
            "name": "Commit-0",
            "content": "/**\r\n * Efectos visuales adicionales para el menú gótico-cyberpunk de Cybervania\r\n */\r\nexport class MenuEffects {\r\n    constructor(menuContainer) {\r\n        this.container = document.getElementById(menuContainer);\r\n        this.transitionElement = null;\r\n        this.glitchInterval = null;\r\n        this.initialize();\r\n    }\r\n    \r\n    initialize() {\r\n        this.createTransitionLayer();\r\n        this.setupGlitchEffects();\r\n        this.setupTitleEffect();\r\n    }\r\n    \r\n    createTransitionLayer() {\r\n        // Crear capa para transiciones\r\n        this.transitionElement = document.createElement('div');\r\n        this.transitionElement.className = 'transition-glitch';\r\n        document.body.appendChild(this.transitionElement);\r\n    }\r\n    \r\n    setupGlitchEffects() {\r\n        // Aplicar efectos de glitch aleatorios a elementos\r\n        document.querySelectorAll('.menu-item, button, .title-container h1').forEach(el => {\r\n            el.addEventListener('mouseenter', () => this.applyRandomGlitch(el));\r\n            el.addEventListener('mouseleave', () => this.removeGlitch(el));\r\n        });\r\n    }\r\n    \r\n    setupTitleEffect() {\r\n        // Configurar atributo data-text para el efecto de título\r\n        const title = document.querySelector('.title-container h1');\r\n        if (title) {\r\n            title.setAttribute('data-text', title.textContent);\r\n        }\r\n    }\r\n    \r\n    applyRandomGlitch(element) {\r\n        // Probabilidad baja de aplicar efecto glitch\r\n        if (Math.random() < 0.3) {\r\n            this.glitchInterval = setInterval(() => {\r\n                // Aplicar distorsión visual sutil\r\n                const intensity = Math.random() * 2 + 1;\r\n                const xOffset = (Math.random() - 0.5) * intensity;\r\n                const yOffset = (Math.random() - 0.5) * intensity;\r\n                \r\n                element.style.transform = `translate(${xOffset}px, ${yOffset}px)`;\r\n                \r\n                // Cambiar color brevemente\r\n                if (Math.random() < 0.2) {\r\n                    element.style.color = 'rgba(255, 50, 150, 0.9)';\r\n                    setTimeout(() => {\r\n                        element.style.color = '';\r\n                    }, 50);\r\n                }\r\n            }, 100);\r\n        }\r\n    }\r\n    \r\n    removeGlitch(element) {\r\n        clearInterval(this.glitchInterval);\r\n        element.style.transform = '';\r\n    }\r\n    \r\n    playTransition() {\r\n        document.body.classList.add('transition-active');\r\n        \r\n        setTimeout(() => {\r\n            document.body.classList.remove('transition-active');\r\n        }, 600);\r\n    }\r\n    \r\n    // Método para simular problema de recepción como en viejas TVs\r\n    simulateSignalInterference(duration = 500) {\r\n        const interference = document.createElement('div');\r\n        interference.style.cssText = `\r\n            position: fixed;\r\n            top: 0;\r\n            left: 0;\r\n            width: 100%;\r\n            height: 100%;\r\n            background: repeating-linear-gradient(\r\n                0deg,\r\n                rgba(0, 0, 0, 0.1),\r\n                rgba(0, 0, 0, 0.1) 1px,\r\n                rgba(255, 255, 255, 0.1) 1px,\r\n                rgba(255, 255, 255, 0.1) 2px\r\n            );\r\n            pointer-events: none;\r\n            z-index: 9999;\r\n            opacity: 0;\r\n            animation: interference 0.5s ease;\r\n        `;\r\n        \r\n        document.body.appendChild(interference);\r\n        \r\n        // Crear keyframe dinámico\r\n        const style = document.createElement('style');\r\n        style.textContent = `\r\n            @keyframes interference {\r\n                0% { opacity: 0; }\r\n                10% { opacity: 0.8; }\r\n                20% { opacity: 0.2; }\r\n                30% { opacity: 0.7; }\r\n                40% { opacity: 0.3; }\r\n                50% { opacity: 0.9; }\r\n                60% { opacity: 0.2; }\r\n                70% { opacity: 0.7; }\r\n                80% { opacity: 0.1; }\r\n                90% { opacity: 0.5; }\r\n                100% { opacity: 0; }\r\n            }\r\n        `;\r\n        document.head.appendChild(style);\r\n        \r\n        // Eliminar después de la animación\r\n        setTimeout(() => {\r\n            interference.remove();\r\n            style.remove();\r\n        }, duration);\r\n    }\r\n}\r\n"
        }
    ]
}