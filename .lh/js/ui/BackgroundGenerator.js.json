{
    "sourceFile": "js/ui/BackgroundGenerator.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1741033781264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1741033870299,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,33 @@\n+/**\r\n+ * Generador de fondos procedurales con estética retro\r\n+ * Crea fondos pixelados al estilo de juegos SNES sin depender de imágenes externas\r\n+ */\r\n+export class BackgroundGenerator {\r\n+    constructor() {\r\n+        this.canvas = document.createElement('canvas');\r\n+        this.ctx = this.canvas.getContext('2d');\r\n+        this.pixelSize = 4;\r\n+        this.colors = {\r\n+            castleBg: ['#090a10', '#1a0b22', '#320f55', '#29366f'],\r\n+            castleWalls: ['#333c57', '#566c86', '#43156c', '#2d3273'],\r\n+            castleDetails: ['#800e0e', '#a5161d', '#b13e53', '#5d2e46']\r\n+        };\r\n+    }\r\n+    \r\n+    /**\r\n+     * Genera un fondo pixelado de castillo/mazmorra\r\n+     * @returns {string} URL de la imagen generada\r\n+     */\r\n+    generateCastleBackground() {\r\n+        const width = 512;\r\n+        const height = 512;\r\n+        \r\n+        this.canvas.width = width;\r\n+        this.canvas.height = height;\r\n+        \r\n+        // Fondo\r\n+        this.ctx.fillStyle = this.colors.castleBg[0];\r\n+        this.ctx.fillRect(0, 0, width, height);\r\n+        \r\n+        // Crear patrón de ladrillos\r\n+        this.drawBricks();\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741034097024,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,38 +29,524 @@\n         this.ctx.fillStyle = this.colors.castleBg[0];\r\n         this.ctx.fillRect(0, 0, width, height);\r\n         \r\n         // Crear patrón de ladrillos\r\n-        this.drawBricks();\n-/**\r\n- * Generador de fondos procedurales con estética retro\r\n- * Crea fondos pixelados al estilo de juegos SNES sin depender de imágenes externas\r\n- */\r\n-export class BackgroundGenerator {\r\n-    constructor() {\r\n-        this.canvas = document.createElement('canvas');\r\n-        this.ctx = this.canvas.getContext('2d');\r\n-        this.pixelSize = 4;\r\n-        this.colors = {\r\n-            castleBg: ['#090a10', '#1a0b22', '#320f55', '#29366f'],\r\n-            castleWalls: ['#333c57', '#566c86', '#43156c', '#2d3273'],\r\n-            castleDetails: ['#800e0e', '#a5161d', '#b13e53', '#5d2e46']\r\n-        };\r\n+        this.drawBricks();\r\n+        \r\n+        // Agregar columnas\r\n+        this.drawColumns();\r\n+        \r\n+        // Agregar decoraciones góticas\r\n+        this.drawGothicDetails();\r\n+        \r\n+        // Agregar efectos de iluminación\r\n+        this.addLighting();\r\n+        \r\n+        // Agregar niebla digital\r\n+        this.addDigitalMist();\r\n+        \r\n+        // Devolver la URL de la imagen generada\r\n+        return this.canvas.toDataURL('image/png');\r\n     }\r\n     \r\n     /**\r\n\\ No newline at end of file\n-     * Genera un fondo pixelado de castillo/mazmorra\r\n-     * @returns {string} URL de la imagen generada\r\n+     * Genera un patrón para ser usado como borde\r\n+     * @returns {string} URL del patrón de borde\r\n      */\r\n-    generateCastleBackground() {\r\n-        const width = 512;\r\n-        const height = 512;\r\n+    generatePixelBorder() {\r\n+        const borderSize = 32;\r\n         \r\n-        this.canvas.width = width;\r\n-        this.canvas.height = height;\r\n+        this.canvas.width = borderSize;\r\n+        this.canvas.height = borderSize;\r\n         \r\n-        // Fondo\r\n+        // Limpiar canvas\r\n+        this.ctx.clearRect(0, 0, borderSize, borderSize);\r\n+        \r\n+        // Color de fondo\r\n+        this.ctx.fillStyle = this.colors.castleDetails[0];\r\n+        this.ctx.fillRect(0, 0, borderSize, borderSize);\r\n+        \r\n+        // Dibujar el borde pixelado\r\n+        this.ctx.fillStyle = this.colors.castleDetails[1];\r\n+        \r\n+        // Borde exterior\r\n+        this.ctx.fillRect(0, 0, borderSize, this.pixelSize);\r\n+        this.ctx.fillRect(0, borderSize - this.pixelSize, borderSize, this.pixelSize);\r\n+        this.ctx.fillRect(0, 0, this.pixelSize, borderSize);\r\n+        this.ctx.fillRect(borderSize - this.pixelSize, 0, this.pixelSize, borderSize);\r\n+        \r\n+        // Detalles de esquina\r\n+        this.ctx.fillStyle = this.colors.castleDetails[2];\r\n+        this.ctx.fillRect(0, 0, this.pixelSize * 2, this.pixelSize * 2);\r\n+        this.ctx.fillRect(borderSize - this.pixelSize * 2, 0, this.pixelSize * 2, this.pixelSize * 2);\r\n+        this.ctx.fillRect(0, borderSize - this.pixelSize * 2, this.pixelSize * 2, this.pixelSize * 2);\r\n+        this.ctx.fillRect(borderSize - this.pixelSize * 2, borderSize - this.pixelSize * 2, this.pixelSize * 2, this.pixelSize * 2);\r\n+        \r\n+        // Detalle adicional para estilo gótico\r\n+        this.ctx.fillStyle = this.colors.castleBg[2];\r\n+        this.ctx.fillRect(this.pixelSize * 4, this.pixelSize, this.pixelSize, this.pixelSize);\r\n+        this.ctx.fillRect(borderSize - this.pixelSize * 5, this.pixelSize, this.pixelSize, this.pixelSize);\r\n+        this.ctx.fillRect(this.pixelSize * 4, borderSize - this.pixelSize * 2, this.pixelSize, this.pixelSize);\r\n+        this.ctx.fillRect(borderSize - this.pixelSize * 5, borderSize - this.pixelSize * 2, this.pixelSize, this.pixelSize);\r\n+        \r\n+        return this.canvas.toDataURL('image/png');\r\n+    }\r\n+    \r\n+    /**\r\n+     * Dibuja un patrón de ladrillos en el fondo\r\n+     */\r\n+    drawBricks() {\r\n+        const brickWidth = this.pixelSize * 10;\r\n+        const brickHeight = this.pixelSize * 4;\r\n+        const offset = this.pixelSize * 5;\r\n+        \r\n+        // Calculamos cuántas filas y columnas necesitamos\r\n+        const rows = Math.ceil(this.canvas.height / brickHeight);\r\n+        const cols = Math.ceil(this.canvas.width / brickWidth) + 1; // +1 para manejar el offset\r\n+        \r\n+        // Color principal de los ladrillos\r\n+        const mainColor = this.colors.castleWalls[1];\r\n+        const darkColor = this.colors.castleWalls[0];\r\n+        const detailColor = this.colors.castleWalls[2];\r\n+        \r\n+        // Dibujar las filas de ladrillos\r\n+        for (let row = 0; row < rows; row++) {\r\n+            const rowOffset = row % 2 === 0 ? 0 : offset;\r\n+            \r\n+            for (let col = -1; col < cols; col++) {\r\n+                // Posición del ladrillo\r\n+                const x = col * brickWidth + rowOffset;\r\n+                const y = row * brickHeight;\r\n+                \r\n+                // Color con variaciones aleatorias\r\n+                const colorVariation = Math.random() > 0.8 ? detailColor : mainColor;\r\n+                this.ctx.fillStyle = colorVariation;\r\n+                \r\n+                // Dibujar el ladrillo principal\r\n+                this.ctx.fillRect(x, y, brickWidth - this.pixelSize, brickHeight - this.pixelSize);\r\n+                \r\n+                // Agregar sombra\r\n+                this.ctx.fillStyle = darkColor;\r\n+                this.ctx.fillRect(x, y + brickHeight - this.pixelSize, brickWidth - this.pixelSize, this.pixelSize);\r\n+                this.ctx.fillRect(x + brickWidth - this.pixelSize, y, this.pixelSize, brickHeight);\r\n+            }\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Dibuja columnas decorativas en los lados\r\n+     */\r\n+    drawColumns() {\r\n+        const columnWidth = this.pixelSize * 8;\r\n+        const columnCount = 3;\r\n+        const columnSpacing = this.canvas.height / (columnCount + 1);\r\n+        \r\n+        // Colores para la columna\r\n+        const baseColor = this.colors.castleDetails[0];\r\n+        const highlightColor = this.colors.castleDetails[3];\r\n+        const capColor = this.colors.castleDetails[1];\r\n+        \r\n+        // Dibujar columnas en ambos lados\r\n+        for (let side = 0; side < 2; side++) {\r\n+            const x = side === 0 ? this.pixelSize * 4 : this.canvas.width - columnWidth - this.pixelSize * 4;\r\n+            \r\n+            for (let col = 0; col < columnCount; col++) {\r\n+                const y = (col + 1) * columnSpacing;\r\n+                \r\n+                // Base de la columna\r\n+                this.ctx.fillStyle = baseColor;\r\n+                this.ctx.fillRect(x, y - columnWidth, columnWidth, columnWidth * 2);\r\n+                \r\n+                // Detalle superior e inferior\r\n+                this.ctx.fillStyle = capColor;\r\n+                this.ctx.fillRect(x - this.pixelSize, y - columnWidth - this.pixelSize * 2, columnWidth + this.pixelSize * 2, this.pixelSize * 2);\r\n+                this.ctx.fillRect(x - this.pixelSize, y + columnWidth, columnWidth + this.pixelSize * 2, this.pixelSize * 2);\r\n+                \r\n+                // Detalles decorativos\r\n+                this.ctx.fillStyle = highlightColor;\r\n+                this.ctx.fillRect(x + this.pixelSize * 2, y - columnWidth + this.pixelSize, columnWidth - this.pixelSize * 4, this.pixelSize);\r\n+                this.ctx.fillRect(x + this.pixelSize * 2, y + columnWidth - this.pixelSize * 2, columnWidth - this.pixelSize * 4, this.pixelSize);\r\n+            }\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Agrega detalles góticos al fondo\r\n+     */\r\n+    drawGothicDetails() {\r\n+        // Agregar ventanas góticas\r\n+        this.drawGothicWindows();\r\n+        \r\n+        // Agregar símbolos arcanos\r\n+        this.drawArcaneSymbols();\r\n+        \r\n+        // Agregar elementos cyberpunk\r\n+        this.drawCyberpunkElements();\r\n+    }\r\n+    \r\n+    /**\r\n+     * Dibuja ventanas góticas en el fondo\r\n+     */\r\n+    drawGothicWindows() {\r\n+        const windowWidth = this.pixelSize * 12;\r\n+        const windowHeight = this.pixelSize * 20;\r\n+        const windowCount = 2;\r\n+        \r\n+        // Colores para las ventanas\r\n+        const frameColor = this.colors.castleDetails[3];\r\n+        const glassColor = '#1a0b22';\r\n+        const detailColor = this.colors.castleDetails[2];\r\n+        \r\n+        // Posiciones X para las ventanas\r\n+        const windowPositions = [\r\n+            this.canvas.width / 3 - windowWidth / 2,\r\n+            this.canvas.width * 2/3 - windowWidth / 2\r\n+        ];\r\n+        \r\n+        // Dibujar cada ventana\r\n+        for (let i = 0; i < windowCount; i++) {\r\n+            const x = windowPositions[i];\r\n+            const y = this.canvas.height / 4;\r\n+            \r\n+            // Marco exterior\r\n+            this.ctx.fillStyle = frameColor;\r\n+            this.ctx.fillRect(x, y, windowWidth, windowHeight);\r\n+            \r\n+            // Vidrio interior\r\n+            this.ctx.fillStyle = glassColor;\r\n+            this.ctx.fillRect(x + this.pixelSize * 2, y + this.pixelSize * 2, windowWidth - this.pixelSize * 4, windowHeight - this.pixelSize * 4);\r\n+            \r\n+            // División gótica en forma de arco\r\n+            this.ctx.fillStyle = frameColor;\r\n+            \r\n+            // Divisiones verticales\r\n+            this.ctx.fillRect(x + windowWidth/2 - this.pixelSize/2, y + this.pixelSize * 2, this.pixelSize, windowHeight - this.pixelSize * 6);\r\n+            \r\n+            // División horizontal\r\n+            this.ctx.fillRect(x + this.pixelSize * 2, y + windowHeight/2 - this.pixelSize/2, windowWidth - this.pixelSize * 4, this.pixelSize);\r\n+            \r\n+            // Arco superior\r\n+            const arcWidth = windowWidth - this.pixelSize * 4;\r\n+            const arcHeight = this.pixelSize * 6;\r\n+            const arcX = x + this.pixelSize * 2;\r\n+            const arcY = y + this.pixelSize * 2;\r\n+            \r\n+            // Detalle del arco (simplificado para pixel art)\r\n+            this.ctx.fillStyle = detailColor;\r\n+            this.ctx.fillRect(arcX + arcWidth/4, arcY + arcHeight/2, arcWidth/2, this.pixelSize);\r\n+            this.ctx.fillRect(arcX + arcWidth/3, arcY + arcHeight/3, arcWidth/3, this.pixelSize);\r\n+            \r\n+            // Añadir brillo digital (estilo cyberpunk)\r\n+            this.ctx.fillStyle = 'rgba(255, 0, 91, 0.3)';\r\n+            this.ctx.fillRect(x + this.pixelSize * 3, y + this.pixelSize * 3, this.pixelSize, windowHeight - this.pixelSize * 6);\r\n+            this.ctx.fillRect(x + windowWidth - this.pixelSize * 4, y + this.pixelSize * 3, this.pixelSize, windowHeight - this.pixelSize * 6);\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Dibuja símbolos arcanos en el fondo\r\n+     */\r\n+    drawArcaneSymbols() {\r\n+        // Colores para los símbolos\r\n+        const symbolColor = '#ff005b'; // Cyber-pink\r\n+        \r\n+        // Dibujar diferentes símbolos en ubicaciones aleatorias\r\n+        for (let i = 0; i < 5; i++) {\r\n+            const x = this.pixelSize * (10 + Math.floor(Math.random() * (this.canvas.width / this.pixelSize - 20)));\r\n+            const y = this.pixelSize * (10 + Math.floor(Math.random() * (this.canvas.height / this.pixelSize - 20)));\r\n+            const size = this.pixelSize * (4 + Math.floor(Math.random() * 4));\r\n+            \r\n+            this.ctx.fillStyle = symbolColor;\r\n+            \r\n+            // Elegir un tipo de símbolo al azar\r\n+            const symbolType = Math.floor(Math.random() * 4);\r\n+            \r\n+            switch(symbolType) {\r\n+                case 0: // Círculo con cruz\r\n+                    this.ctx.fillRect(x - size/2, y - this.pixelSize/2, size, this.pixelSize);\r\n+                    this.ctx.fillRect(x - this.pixelSize/2, y - size/2, this.pixelSize, size);\r\n+                    this.ctx.beginPath();\r\n+                    this.ctx.arc(x, y, size/2 + this.pixelSize, 0, Math.PI * 2);\r\n+                    this.ctx.lineWidth = this.pixelSize;\r\n+                    this.ctx.strokeStyle = symbolColor;\r\n+                    this.ctx.stroke();\r\n+                    break;\r\n+                    \r\n+                case 1: // Triángulo\r\n+                    for (let i = 0; i < size/this.pixelSize; i++) {\r\n+                        const width = (size - i * this.pixelSize * 2);\r\n+                        if (width > 0) {\r\n+                            this.ctx.fillRect(x - width/2, y + i * this.pixelSize, width, this.pixelSize);\r\n+                        }\r\n+                    }\r\n+                    break;\r\n+                    \r\n+                case 2: // Pentágono pixelado\r\n+                    this.ctx.fillRect(x - this.pixelSize, y - size/2, this.pixelSize * 2, this.pixelSize);\r\n+                    this.ctx.fillRect(x - size/3, y - size/4, this.pixelSize, this.pixelSize * 2);\r\n+                    this.ctx.fillRect(x + size/3 - this.pixelSize, y - size/4, this.pixelSize, this.pixelSize * 2);\r\n+                    this.ctx.fillRect(x - size/2, y + this.pixelSize, size, this.pixelSize);\r\n+                    break;\r\n+                    \r\n+                case 3: // Símbolo digital\r\n+                    // Cruz con pixeles adicionales\r\n+                    this.ctx.fillRect(x - size/2, y - this.pixelSize/2, size, this.pixelSize);\r\n+                    this.ctx.fillRect(x - this.pixelSize/2, y - size/2, this.pixelSize, size);\r\n+                    this.ctx.fillRect(x - size/3, y - size/3, this.pixelSize, this.pixelSize);\r\n+                    this.ctx.fillRect(x + size/3, y - size/3, this.pixelSize, this.pixelSize);\r\n+                    this.ctx.fillRect(x - size/3, y + size/3, this.pixelSize, this.pixelSize);\r\n+                    this.ctx.fillRect(x + size/3, y + size/3, this.pixelSize, this.pixelSize);\r\n+                    break;\r\n+            }\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Dibuja elementos cyberpunk en el fondo\r\n+     */\r\n+    drawCyberpunkElements() {\r\n+        // Líneas de circuito\r\n+        this.drawCircuitLines();\r\n+        \r\n+        // Terminales/Pantallas\r\n+        this.drawTerminals();\r\n+    }\r\n+    \r\n+    /**\r\n+     * Dibuja líneas de circuito en estilo cyberpunk\r\n+     */\r\n+    drawCircuitLines() {\r\n+        const lineColor = '#00f6ff'; // Cyber-teal\r\n+        const nodeColor = '#ff005b'; // Cyber-pink\r\n+        \r\n+        this.ctx.strokeStyle = lineColor;\r\n+        this.ctx.lineWidth = this.pixelSize / 2;\r\n+        \r\n+        // Crear varias líneas de circuito\r\n+        for (let i = 0; i < 4; i++) {\r\n+            // Punto inicial\r\n+            const startX = Math.random() > 0.5 ? 0 : this.canvas.width;\r\n+            const startY = Math.floor(Math.random() * this.canvas.height / this.pixelSize) * this.pixelSize;\r\n+            \r\n+            // Punto final\r\n+            const endX = startX === 0 ? this.canvas.width : 0;\r\n+            const endY = Math.floor(Math.random() * this.canvas.height / this.pixelSize) * this.pixelSize;\r\n+            \r\n+            // Puntos intermedios\r\n+            let currentX = startX;\r\n+            let currentY = startY;\r\n+            \r\n+            // Crear el camino\r\n+            this.ctx.beginPath();\r\n+            this.ctx.moveTo(currentX, currentY);\r\n+            \r\n+            // Añadir 3-6 segmentos intermedios\r\n+            const segments = 3 + Math.floor(Math.random() * 4);\r\n+            \r\n+            for (let j = 0; j < segments; j++) {\r\n+                // Ir hacia el punto final, con una dirección dominante\r\n+                const directionX = endX > currentX ? 1 : -1;\r\n+                const directionY = endY > currentY ? 1 : -1;\r\n+                \r\n+                // Decidir si movernos horizontal o verticalmente\r\n+                if (Math.random() > 0.5) {\r\n+                    // Mover horizontalmente\r\n+                    const moveX = Math.min(\r\n+                        Math.abs(endX - currentX), \r\n+                        Math.floor(Math.random() * 100) + 50\r\n+                    );\r\n+                    currentX += moveX * directionX;\r\n+                } else {\r\n+                    // Mover verticalmente\r\n+                    const moveY = Math.min(\r\n+                        Math.abs(endY - currentY), \r\n+                        Math.floor(Math.random() * 100) + 50\r\n+                    );\r\n+                    currentY += moveY * directionY;\r\n+                }\r\n+                \r\n+                // Ajustar a la cuadrícula de píxeles\r\n+                currentX = Math.floor(currentX / this.pixelSize) * this.pixelSize;\r\n+                currentY = Math.floor(currentY / this.pixelSize) * this.pixelSize;\r\n+                \r\n+                // Añadir el punto al camino\r\n+                this.ctx.lineTo(currentX, currentY);\r\n+                \r\n+                // Dibujar nodo\r\n+                this.ctx.fillStyle = nodeColor;\r\n+                this.ctx.fillRect(\r\n+                    currentX - this.pixelSize, \r\n+                    currentY - this.pixelSize, \r\n+                    this.pixelSize * 2, \r\n+                    this.pixelSize * 2\r\n+                );\r\n+            }\r\n+            \r\n+            // Completar camino hasta el punto final\r\n+            this.ctx.lineTo(endX, endY);\r\n+            this.ctx.stroke();\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Dibuja terminales/pantallas en estilo cyberpunk\r\n+     */\r\n+    drawTerminals() {\r\n+        const terminalBaseColor = '#1a0b22';\r\n+        const terminalScreenColor = '#004cff';\r\n+        const terminalDetailColor = '#00f6ff';\r\n+        \r\n+        // Dibujar 2-3 terminales\r\n+        const terminalCount = 2 + Math.floor(Math.random() * 2);\r\n+        \r\n+        for (let i = 0; i < terminalCount; i++) {\r\n+            // Posición con bias hacia los bordes\r\n+            let x, y;\r\n+            \r\n+            if (i === 0) {\r\n+                // Primer terminal en la parte inferior izquierda\r\n+                x = this.pixelSize * (5 + Math.floor(Math.random() * 10));\r\n+                y = this.canvas.height - this.pixelSize * (15 + Math.floor(Math.random() * 10));\r\n+            } else if (i === 1) {\r\n+                // Segundo terminal en la parte inferior derecha\r\n+                x = this.canvas.width - this.pixelSize * (15 + Math.floor(Math.random() * 10));\r\n+                y = this.canvas.height - this.pixelSize * (15 + Math.floor(Math.random() * 10));\r\n+            } else {\r\n+                // Otros en posiciones más aleatorias\r\n+                x = this.pixelSize * (10 + Math.floor(Math.random() * ((this.canvas.width / this.pixelSize) - 20)));\r\n+                y = this.pixelSize * (10 + Math.floor(Math.random() * ((this.canvas.height / this.pixelSize) - 20)));\r\n+            }\r\n+            \r\n+            const width = this.pixelSize * (10 + Math.floor(Math.random() * 6));\r\n+            const height = this.pixelSize * (6 + Math.floor(Math.random() * 4));\r\n+            \r\n+            // Base del terminal\r\n+            this.ctx.fillStyle = terminalBaseColor;\r\n+            this.ctx.fillRect(x, y, width, height);\r\n+            \r\n+            // Pantalla\r\n+            this.ctx.fillStyle = terminalScreenColor;\r\n+            this.ctx.fillRect(\r\n+                x + this.pixelSize, \r\n+                y + this.pixelSize, \r\n+                width - this.pixelSize * 2, \r\n+                height - this.pixelSize * 2\r\n+            );\r\n+            \r\n+            // Detalles de la pantalla\r\n+            this.ctx.fillStyle = terminalDetailColor;\r\n+            \r\n+            // Líneas de texto simuladas\r\n+            for (let j = 0; j < 3; j++) {\r\n+                const lineY = y + this.pixelSize * 2 + j * this.pixelSize * 1.5;\r\n+                const lineWidth = Math.floor(Math.random() * (width - this.pixelSize * 4)) + this.pixelSize * 2;\r\n+                \r\n+                this.ctx.fillRect(\r\n+                    x + this.pixelSize * 2,\r\n+                    lineY,\r\n+                    lineWidth,\r\n+                    this.pixelSize / 2\r\n+                );\r\n+            }\r\n+            \r\n+            // Borde con efecto neón\r\n+            this.ctx.strokeStyle = terminalDetailColor;\r\n+            this.ctx.lineWidth = this.pixelSize / 2;\r\n+            this.ctx.strokeRect(\r\n+                x + this.pixelSize / 2, \r\n+                y + this.pixelSize / 2, \r\n+                width - this.pixelSize, \r\n+                height - this.pixelSize\r\n+            );\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Agrega efectos de iluminación al fondo\r\n+     */\r\n+    addLighting() {\r\n+        // Gradiente radial sutil\r\n+        const gradient = this.ctx.createRadialGradient(\r\n+            this.canvas.width / 2, this.canvas.height / 2, 0,\r\n+            this.canvas.width / 2, this.canvas.height / 2, this.canvas.height * 0.7\r\n+        );\r\n+        \r\n+        gradient.addColorStop(0, 'rgba(50, 15, 85, 0.3)');\r\n+        gradient.addColorStop(0.5, 'rgba(50, 15, 85, 0.1)');\r\n+        gradient.addColorStop(1, 'rgba(9, 10, 16, 0.5)');\r\n+        \r\n+        // Aplicar el gradiente\r\n+        this.ctx.fillStyle = gradient;\r\n+        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n+        \r\n+        // Añadir algunos puntos de luz\r\n+        for (let i = 0; i < 5; i++) {\r\n+            const x = Math.random() * this.canvas.width;\r\n+            const y = Math.random() * this.canvas.height;\r\n+            const radius = 20 + Math.random() * 30;\r\n+            const glow = this.ctx.createRadialGradient(\r\n+                x, y, 0,\r\n+                x, y, radius\r\n+            );\r\n+            \r\n+            glow.addColorStop(0, 'rgba(255, 0, 91, 0.3)');\r\n+            glow.addColorStop(0.5, 'rgba(255, 0, 91, 0.1)');\r\n+            glow.addColorStop(1, 'rgba(255, 0, 91, 0)');\r\n+            \r\n+            this.ctx.fillStyle = glow;\r\n+            this.ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Agrega efecto de niebla digital\r\n+     */\r\n+    addDigitalMist() {\r\n+        // Generar una capa de \"niebla\" digital pixelada\r\n+        const mistCount = 200;\r\n+        \r\n+        for (let i = 0; i < mistCount; i++) {\r\n+            const x = Math.random() * this.canvas.width;\r\n+            const y = Math.random() * this.canvas.height;\r\n+            const size = this.pixelSize * (Math.random() > 0.8 ? 2 : 1);\r\n+            \r\n+            // Colores base para la niebla\r\n+            const colors = [\r\n+                'rgba(0, 246, 255, 0.1)',  // Cyber-teal\r\n+                'rgba(255, 0, 91, 0.1)',   // Cyber-pink\r\n+                'rgba(50, 15, 85, 0.1)',   // Cyber-purple\r\n+                'rgba(166, 23, 29, 0.1)',  // Gothic-blood\r\n+            ];\r\n+            \r\n+            // Seleccionar un color aleatorio\r\n+            this.ctx.fillStyle = colors[Math.floor(Math.random() * colors.length)];\r\n+            \r\n+            // Dibujar el pixel de niebla\r\n+            this.ctx.fillRect(x, y, size, size);\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Genera un patrón de fondo simple para usar como fallback\r\n+     */\r\n+    generateFallbackPattern() {\r\n+        const patternSize = 32;\r\n+        \r\n+        this.canvas.width = patternSize;\r\n+        this.canvas.height = patternSize;\r\n+        \r\n+        // Color base\r\n         this.ctx.fillStyle = this.colors.castleBg[0];\r\n-        this.ctx.fillRect(0, 0, width, height);\r\n+        this.ctx.fillRect(0, 0, patternSize, patternSize);\r\n         \r\n-        // Crear patrón de ladrillos\r\n-        this.drawBricks();\n+        // Agregar líneas de cuadrícula\r\n+        this.ctx.fillStyle = this.colors.castleBg[1];\r\n+        this.ctx.fillRect(0, 0, patternSize, 1);\r\n+        this.ctx.fillRect(0, 0, 1, patternSize);\r\n+        \r\n+        // Detalles\r\n+        this.ctx.fillStyle = this.colors.castleBg[2];\r\n+        this.ctx.fillRect(patternSize - 4, patternSize - 4, 4, 4);\r\n+        \r\n+        return this.canvas.toDataURL('image/png');\r\n+    }\r\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1741033781264,
            "name": "Commit-0",
            "content": "/**\r\n * Generador de fondos procedurales con estética retro\r\n * Crea fondos pixelados al estilo de juegos SNES sin depender de imágenes externas\r\n */\r\nexport class BackgroundGenerator {\r\n    constructor() {\r\n        this.canvas = document.createElement('canvas');\r\n        this.ctx = this.canvas.getContext('2d');\r\n        this.pixelSize = 4;\r\n        this.colors = {\r\n            castleBg: ['#090a10', '#1a0b22', '#320f55', '#29366f'],\r\n            castleWalls: ['#333c57', '#566c86', '#43156c', '#2d3273'],\r\n            castleDetails: ['#800e0e', '#a5161d', '#b13e53', '#5d2e46']\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Genera un fondo pixelado de castillo/mazmorra\r\n     * @returns {string} URL de la imagen generada\r\n     */\r\n    generateCastleBackground() {\r\n        const width = 512;\r\n        const height = 512;\r\n        \r\n        this.canvas.width = width;\r\n        this.canvas.height = height;\r\n        \r\n        // Fondo\r\n        this.ctx.fillStyle = this.colors.castleBg[0];\r\n        this.ctx.fillRect(0, 0, width, height);\r\n        \r\n        // Crear patrón de ladrillos\r\n        this.drawBricks();"
        }
    ]
}