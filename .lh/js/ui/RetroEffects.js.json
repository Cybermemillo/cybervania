{
    "sourceFile": "js/ui/RetroEffects.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1741033298466,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1741033773862,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,69 +1,361 @@\n /**\r\n- * Efectos visuales para el estilo retro de 16 bits\r\n+ * Efectos visuales para el tema retro de SNES en Cybervania\r\n+ * Implementa efectos visuales que emulan la estética de 16-bits\r\n  */\r\n export class RetroEffects {\r\n     constructor(containerId) {\r\n         this.container = document.getElementById(containerId);\r\n-        this.createPixelatedBackground();\r\n+        this.pixelSize = 4;\r\n+        this.initialized = false;\r\n+        \r\n+        this.initialize();\r\n     }\r\n     \r\n     /**\r\n-     * Genera un fondo con \"píxeles\" animados al estilo retro\r\n+     * Inicializa los efectos retro\r\n      */\r\n-    createPixelatedBackground() {\r\n-        // Crear contenedor para píxeles\r\n+    initialize() {\r\n+        if (this.initialized) return;\r\n+        \r\n+        // Crear el fondo de píxeles aleatorios\r\n+        this.createPixelBg();\r\n+        \r\n+        // Añadir efecto de líneas de escaneo CRT\r\n+        this.addScanlines();\r\n+        \r\n+        // Añadir efectos de interferencia aleatorios\r\n+        this.setupInterferenceEffects();\r\n+        \r\n+        this.initialized = true;\r\n+    }\r\n+    \r\n+    /**\r\n+     * Crea un fondo con píxeles aleatorios estilo 16-bits\r\n+     */\r\n+    createPixelBg() {\r\n+        // Crear el contenedor para los píxeles\r\n         const pixelContainer = document.createElement('div');\r\n-        pixelContainer.className = 'pixel-background';\r\n+        pixelContainer.className = 'retro-pixel-container';\r\n+        pixelContainer.style.cssText = `\r\n+            position: absolute;\r\n+            top: 0;\r\n+            left: 0;\r\n+            width: 100%;\r\n+            height: 100%;\r\n+            z-index: 0;\r\n+            pointer-events: none;\r\n+            opacity: 0.3;\r\n+        `;\r\n         \r\n-        // Colores en la paleta retro\r\n-        const colors = [\r\n-            '#b13e53', '#ef7d57', '#ffcd75', \r\n-            '#a7f070', '#38b764', '#3b5dc9', \r\n-            '#41a6f6', '#73eff7'\r\n+        // Colores retro para los píxeles\r\n+        const pixelColors = [\r\n+            '#ff005b', // cyber-pink\r\n+            '#00f6ff', // cyber-teal\r\n+            '#c8aa6e', // gothic-gold\r\n+            '#a5161d', // gothic-blood\r\n+            '#8f0a93', // snes-purple\r\n+            '#38b764', // snes-green\r\n+            '#326fd1'  // snes-blue\r\n         ];\r\n         \r\n-        // Generar píxeles\r\n-        const pixelCount = 30;\r\n+        // Crear píxeles dispersos por el fondo\r\n+        const pixelCount = Math.min(30, Math.floor((window.innerWidth * window.innerHeight) / 50000));\r\n+        \r\n         for (let i = 0; i < pixelCount; i++) {\r\n             const pixel = document.createElement('div');\r\n-            pixel.className = 'pixel';\r\n             \r\n-            // Posición aleatoria\r\n+            // Propiedades aleatorias para cada pixel\r\n+            const size = this.pixelSize * (Math.floor(Math.random() * 2) + 1);\r\n             const x = Math.random() * 100;\r\n             const y = Math.random() * 100;\r\n+            const color = pixelColors[Math.floor(Math.random() * pixelColors.length)];\r\n+            const delay = Math.random() * 3;\r\n+            const duration = 1 + Math.random() * 2;\r\n             \r\n-            // Tamaño aleatorio (pero pequeño)\r\n-            const size = Math.random() * 4 + 4;\r\n-            \r\n-            // Color aleatorio de la paleta\r\n-            const color = colors[Math.floor(Math.random() * colors.length)];\r\n-            \r\n             // Aplicar estilos\r\n-            pixel.style.left = `${x}%`;\r\n-            pixel.style.top = `${y}%`;\r\n-            pixel.style.width = `${size}px`;\r\n-            pixel.style.height = `${size}px`;\r\n-            pixel.style.backgroundColor = color;\r\n-            pixel.style.opacity = Math.random() * 0.3 + 0.1;\r\n+            pixel.className = 'retro-pixel';\r\n+            pixel.style.cssText = `\r\n+                position: absolute;\r\n+                width: ${size}px;\r\n+                height: ${size}px;\r\n+                background-color: ${color};\r\n+                left: ${x}%;\r\n+                top: ${y}%;\r\n+                opacity: ${Math.random() * 0.5 + 0.2};\r\n+                animation: pixel-blink ${duration}s infinite ${delay}s steps(2);\r\n+            `;\r\n             \r\n-            // Animación simple\r\n-            pixel.style.animation = `pixel-flicker ${Math.random() * 2 + 1}s infinite steps(2)`;\r\n-            \r\n             pixelContainer.appendChild(pixel);\r\n         }\r\n         \r\n-        // Añadir al DOM\r\n         this.container.appendChild(pixelContainer);\r\n         \r\n-        // Crear estilos para la animación\r\n+        // Crear la animación de parpadeo\r\n         const style = document.createElement('style');\r\n         style.textContent = `\r\n-            @keyframes pixel-flicker {\r\n-                0% { opacity: 0.1; }\r\n-                50% { opacity: 0.3; }\r\n-                100% { opacity: 0.1; }\r\n+            @keyframes pixel-blink {\r\n+                0%, 49% { opacity: 0.1; }\r\n+                50%, 100% { opacity: 0.5; }\r\n             }\r\n         `;\r\n         document.head.appendChild(style);\r\n     }\r\n-}\r\n+    \r\n+    /**\r\n+     * Añade el efecto de líneas de escaneo tipo CRT\r\n+     */\r\n+    addScanlines() {\r\n+        const scanlines = document.createElement('div');\r\n+        scanlines.className = 'retro-scanlines';\r\n+        scanlines.style.cssText = `\r\n+            position: fixed;\r\n+            top: 0;\r\n+            left: 0;\r\n+            width: 100%;\r\n+            height: 100%;\r\n+            background: repeating-linear-gradient(\r\n+                to bottom,\r\n+                transparent,\r\n+                transparent 2px,\r\n+                rgba(0, 0, 0, 0.05) 3px,\r\n+                rgba(0, 0, 0, 0.05) 3px\r\n+            );\r\n+            pointer-events: none;\r\n+            z-index: 9999;\r\n+            opacity: 0.4;\r\n+        `;\r\n+        \r\n+        document.body.appendChild(scanlines);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Configura efectos de interferencia aleatorios\r\n+     */\r\n+    setupInterferenceEffects() {\r\n+        // Efecto de interferencia que ocurre ocasionalmente\r\n+        setInterval(() => {\r\n+            if (Math.random() > 0.8) { // 20% de probabilidad\r\n+                this.createGlitchEffect();\r\n+            }\r\n+        }, 10000); // Cada 10 segundos\r\n+    }\r\n+    \r\n+    /**\r\n+     * Crea un efecto de glitch/interferencia temporal\r\n+     */\r\n+    createGlitchEffect() {\r\n+        const glitch = document.createElement('div');\r\n+        glitch.className = 'retro-glitch-effect';\r\n+        \r\n+        const glitchType = Math.floor(Math.random() * 3); // 3 tipos diferentes\r\n+        \r\n+        switch(glitchType) {\r\n+            case 0: // Desplazamiento horizontal\r\n+                glitch.style.cssText = `\r\n+                    position: fixed;\r\n+                    top: 0;\r\n+                    left: 0;\r\n+                    width: 100%;\r\n+                    height: 100%;\r\n+                    background-color: transparent;\r\n+                    overflow: hidden;\r\n+                    pointer-events: none;\r\n+                    z-index: 9998;\r\n+                `;\r\n+                \r\n+                // Crear 3-5 secciones desplazadas\r\n+                const sliceCount = Math.floor(Math.random() * 3) + 3;\r\n+                const height = 100 / sliceCount;\r\n+                \r\n+                for (let i = 0; i < sliceCount; i++) {\r\n+                    const slice = document.createElement('div');\r\n+                    const offset = Math.floor(Math.random() * 20) - 10; // -10px a 10px\r\n+                    \r\n+                    slice.style.cssText = `\r\n+                        position: absolute;\r\n+                        top: ${i * height}%;\r\n+                        left: 0;\r\n+                        width: 100%;\r\n+                        height: ${height}%;\r\n+                        transform: translateX(${offset}px);\r\n+                        background-color: transparent;\r\n+                        overflow: hidden;\r\n+                    `;\r\n+                    \r\n+                    glitch.appendChild(slice);\r\n+                }\r\n+                break;\r\n+                \r\n+            case 1: // Flash de color\r\n+                const colors = ['rgba(255,0,91,0.1)', 'rgba(0,246,255,0.1)', 'rgba(141,0,196,0.1)'];\r\n+                const color = colors[Math.floor(Math.random() * colors.length)];\r\n+                \r\n+                glitch.style.cssText = `\r\n+                    position: fixed;\r\n+                    top: 0;\r\n+                    left: 0;\r\n+                    width: 100%;\r\n+                    height: 100%;\r\n+                    background-color: ${color};\r\n+                    mix-blend-mode: overlay;\r\n+                    pointer-events: none;\r\n+                    z-index: 9998;\r\n+                `;\r\n+                break;\r\n+                \r\n+            case 2: // Líneas de ruido\r\n+                glitch.style.cssText = `\r\n+                    position: fixed;\r\n+                    top: 0;\r\n+                    left: 0;\r\n+                    width: 100%;\r\n+                    height: 100%;\r\n+                    background-image: repeating-linear-gradient(\r\n+                        to bottom,\r\n+                        transparent,\r\n+                        transparent 1px,\r\n+                        rgba(255, 255, 255, 0.2) 1px,\r\n+                        rgba(255, 255, 255, 0.2) 2px\r\n+                    );\r\n+                    pointer-events: none;\r\n+                    z-index: 9998;\r\n+                    animation: noise-move 0.2s steps(4) infinite;\r\n+                `;\r\n+                \r\n+                const noiseStyle = document.createElement('style');\r\n+                noiseStyle.textContent = `\r\n+                    @keyframes noise-move {\r\n+                        0% { background-position: 0 0; }\r\n+                        100% { background-position: 100px 0; }\r\n+                    }\r\n+                `;\r\n+                document.head.appendChild(noiseStyle);\r\n+                break;\r\n+        }\r\n+        \r\n+        // Añadir a document\r\n+        document.body.appendChild(glitch);\r\n+        \r\n+        // Eliminar después de un breve tiempo\r\n+        setTimeout(() => {\r\n+            glitch.remove();\r\n+        }, 500);\r\n+    }\r\n+    \r\n+    /**\r\n+     * Crea un efecto pixelado dkinámica para transiciones\r\n+     * @param {string} type - Tipo de transición ('fade', 'pixelate', 'dissolve')\r\n+     * @param {number} duration - Duración en ms\r\n+     * @param {Function} callback - Función a llamar al finalizar\r\n+     */\r\n+    createTransition(type = 'pixelate', duration = 500, callback = null) {\r\n+        const transition = document.createElement('div');\r\n+        transition.className = 'retro-transition';\r\n+        \r\n+        switch(type) {\r\n+            case 'fade':\r\n+                transition.style.cssText = `\r\n+                    position: fixed;\r\n+                    top: 0;\r\n+                    left: 0;\r\n+                    width: 100%;\r\n+                    height: 100%;\r\n+                    background-color: black;\r\n+                    opacity: 0;\r\n+                    z-index: 10000;\r\n+                    transition: opacity ${duration/1000}s ease;\r\n+                    pointer-events: none;\r\n+                `;\r\n+                \r\n+                document.body.appendChild(transition);\r\n+                \r\n+                // Ejecutar la transición\r\n+                setTimeout(() => {\r\n+                    transition.style.opacity = '1';\r\n+                    \r\n+                    setTimeout(() => {\r\n+                        if (callback) callback();\r\n+                        \r\n+                        setTimeout(() => {\r\n+                            transition.style.opacity = '0';\r\n+                            setTimeout(() => transition.remove(), duration);\r\n+                        }, 100);\r\n+                    }, duration);\r\n+                }, 10);\r\n+                break;\r\n+                \r\n+            case 'pixelate':\r\n+                transition.style.cssText = `\r\n+                    position: fixed;\r\n+                    top: 0;\r\n+                    left: 0;\r\n+                    width: 100%;\r\n+                    height: 100%;\r\n+                    background-color: transparent;\r\n+                    z-index: 10000;\r\n+                    pointer-events: none;\r\n+                    display: grid;\r\n+                    grid-template-columns: repeat(16, 1fr);\r\n+                    grid-template-rows: repeat(12, 1fr);\r\n+                    gap: 0;\r\n+                `;\r\n+                \r\n+                // Crear bloques pixelados para la transición\r\n+                const colors = ['#1a0b22', '#320f55', '#000000', '#210069'];\r\n+                \r\n+                for (let i = 0; i < 192; i++) { // 16x12 grid\r\n+                    const block = document.createElement('div');\r\n+                    const color = colors[Math.floor(Math.random() * colors.length)];\r\n+                    const delay = Math.random() * 200;\r\n+                    \r\n+                    block.style.cssText = `\r\n+                        background-color: ${color};\r\n+                        opacity: 0;\r\n+                        transition: opacity 0.2s ease;\r\n+                        transition-delay: ${delay}ms;\r\n+                    `;\r\n+                    \r\n+                    transition.appendChild(block);\r\n+                }\r\n+                \r\n+                document.body.appendChild(transition);\r\n+                \r\n+                // Ejecutar la transición\r\n+                const blocks = transition.querySelectorAll('div');\r\n+                \r\n+                setTimeout(() => {\r\n+                    blocks.forEach(block => {\r\n+                        block.style.opacity = '1';\r\n+                    });\r\n+                    \r\n+                    setTimeout(() => {\r\n+                        if (callback) callback();\r\n+                        \r\n+                        setTimeout(() => {\r\n+                            blocks.forEach(block => {\r\n+                                block.style.opacity = '0';\r\n+                            });\r\n+                            setTimeout(() => transition.remove(), 400);\r\n+                        }, 200);\r\n+                    }, duration);\r\n+                }, 10);\r\n+                break;\r\n+                \r\n+            case 'dissolve':\r\n+                // Crear un lienzo para el efecto de disolución\r\n+                const canvas = document.createElement('canvas');\r\n+                canvas.width = window.innerWidth;\r\n+                canvas.height = window.innerHeight;\r\n+                \r\n+                canvas.style.cssText = `\r\n+                    position: fixed;\r\n+                    top: 0;\r\n+                    left: 0;\r\n+                    width: 100%;\r\n+                    height: 100%;\r\n+                    z-index: 10000;\r\n+                    pointer-events: none;\r\n+                `;\r\n+                \r\n+                document.body.appendChild(canvas);\r\n+                \n\\ No newline at end of file\n"
                },
                {
                    "date": 1741033781284,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -357,5 +357,73 @@\n                     pointer-events: none;\r\n                 `;\r\n                 \r\n                 document.body.appendChild(canvas);\r\n-                \n\\ No newline at end of file\n+                \r\n+                const ctx = canvas.getContext('2d');\r\n+                const pixelSize = this.pixelSize * 2;\r\n+                const cols = Math.ceil(canvas.width / pixelSize);\r\n+                const rows = Math.ceil(canvas.height / pixelSize);\r\n+                const total = cols * rows;\r\n+                let current = 0;\r\n+                \r\n+                const pixels = Array.from({ length: total }, (_, i) => ({\r\n+                    col: i % cols,\r\n+                    row: Math.floor(i / cols),\r\n+                    active: false\r\n+                })).sort(() => Math.random() - 0.5); // Orden aleatorio\r\n+                \r\n+                // Función para dibujar un frame\r\n+                const drawFrame = () => {\r\n+                    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n+                    ctx.fillStyle = 'black';\r\n+                    \r\n+                    pixels.forEach((pixel, index) => {\r\n+                        if (index < current) {\r\n+                            ctx.fillRect(\r\n+                                pixel.col * pixelSize,\r\n+                                pixel.row * pixelSize,\r\n+                                pixelSize,\r\n+                                pixelSize\r\n+                            );\r\n+                        }\r\n+                    });\r\n+                };\r\n+                \r\n+                // Animar la transición\r\n+                const startTime = Date.now();\r\n+                const halfDuration = duration / 2;\r\n+                \r\n+                const animate = () => {\r\n+                    const elapsed = Date.now() - startTime;\r\n+                    \r\n+                    if (elapsed < halfDuration) {\r\n+                        // Primera mitad: aparecer\r\n+                        current = Math.floor((elapsed / halfDuration) * total);\r\n+                        drawFrame();\r\n+                        requestAnimationFrame(animate);\r\n+                    } else if (elapsed < duration) {\r\n+                        // Ejecutar callback a la mitad\r\n+                        if (elapsed - halfDuration < 50 && callback) {\r\n+                            callback();\r\n+                        }\r\n+                        \r\n+                        // Segunda mitad: desaparecer\r\n+                        current = total - Math.floor(((elapsed - halfDuration) / halfDuration) * total);\r\n+                        drawFrame();\r\n+                        requestAnimationFrame(animate);\r\n+                    } else {\r\n+                        // Eliminar al finalizar\r\n+                        canvas.remove();\r\n+                    }\r\n+                };\r\n+                \r\n+                requestAnimationFrame(animate);\r\n+                break;\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Aplica efecto de texto pixelado a un elemento\r\n+     * @param {HTMLElement} element - Elemento al que aplicar el efecto\r\n+     */\r\n+    applyPixelTextEffect(element) {\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741033789206,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -425,5 +425,12 @@\n     /**\r\n      * Aplica efecto de texto pixelado a un elemento\r\n      * @param {HTMLElement} element - Elemento al que aplicar el efecto\r\n      */\r\n-    applyPixelTextEffect(element) {\n\\ No newline at end of file\n+    applyPixelTextEffect(element) {\r\n+        if (!element) return;\r\n+        \r\n+        // Guardar el texto original como dato\r\n+        element.dataset.originalText = element.textContent;\r\n+        \r\n+        // Crear el efecto de revelación de texto\r\n+        const animateText = () => {\n\\ No newline at end of file\n"
                },
                {
                    "date": 1741033870181,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -432,5 +432,85 @@\n         // Guardar el texto original como dato\r\n         element.dataset.originalText = element.textContent;\r\n         \r\n         // Crear el efecto de revelación de texto\r\n-        const animateText = () => {\n\\ No newline at end of file\n+        const animateText = () => {\r\n+            const text = element.dataset.originalText;\r\n+            let displayText = '';\r\n+            let charIndex = 0;\r\n+            \r\n+            const revealInterval = setInterval(() => {\r\n+                if (charIndex < text.length) {\r\n+                    displayText += text.charAt(charIndex);\r\n+                    element.textContent = displayText;\r\n+                    charIndex++;\r\n+                } else {\r\n+                    clearInterval(revealInterval);\r\n+                }\r\n+            }, 50); // Velocidad de revelación\r\n+        };\r\n+        \r\n+        // Ejecutar ahora o en un evento\r\n+        if (element.offsetParent !== null) { // Es visible\r\n+            animateText();\r\n+        } else {\r\n+            const observer = new IntersectionObserver((entries) => {\r\n+                entries.forEach(entry => {\r\n+                    if (entry.isIntersecting) {\r\n+                        animateText();\r\n+                        observer.unobserve(entry.target);\r\n+                    }\r\n+                });\r\n+            });\r\n+            \r\n+            observer.observe(element);\r\n+        }\r\n+    }\r\n+    \r\n+    /**\r\n+     * Crea un \"frame\" pixelado alrededor de un elemento\r\n+     * @param {HTMLElement} element - Elemento al que aplicar el marco\r\n+     */\r\n+    createPixelFrame(element) {\r\n+        if (!element) return;\r\n+        \r\n+        element.style.position = 'relative';\r\n+        \r\n+        // Crear el marco\r\n+        const frame = document.createElement('div');\r\n+        frame.className = 'retro-pixel-frame';\r\n+        frame.style.cssText = `\r\n+            position: absolute;\r\n+            top: -${this.pixelSize}px;\r\n+            left: -${this.pixelSize}px;\r\n+            right: -${this.pixelSize}px;\r\n+            bottom: -${this.pixelSize}px;\r\n+            border: ${this.pixelSize}px solid var(--gothic-gold);\r\n+            z-index: -1;\r\n+            pointer-events: none;\r\n+        `;\r\n+        \r\n+        // Añadir esquinas pixeladas\r\n+        const corners = [\r\n+            { top: '-8px', left: '-8px' },\r\n+            { top: '-8px', right: '-8px' },\r\n+            { bottom: '-8px', left: '-8px' },\r\n+            { bottom: '-8px', right: '-8px' }\r\n+        ];\r\n+        \r\n+        corners.forEach(position => {\r\n+            const corner = document.createElement('div');\r\n+            corner.style.cssText = `\r\n+                position: absolute;\r\n+                width: 12px;\r\n+                height: 12px;\r\n+                background-color: var(--cyber-pink);\r\n+                ${Object.keys(position)[0]}: ${position[Object.keys(position)[0]]};\r\n+                ${Object.keys(position)[1]}: ${position[Object.keys(position)[1]]};\r\n+            `;\r\n+            \r\n+            frame.appendChild(corner);\r\n+        });\r\n+        \r\n+        element.appendChild(frame);\r\n+    }\r\n+}\r\n"
                }
            ],
            "date": 1741033298466,
            "name": "Commit-0",
            "content": "/**\r\n * Efectos visuales para el estilo retro de 16 bits\r\n */\r\nexport class RetroEffects {\r\n    constructor(containerId) {\r\n        this.container = document.getElementById(containerId);\r\n        this.createPixelatedBackground();\r\n    }\r\n    \r\n    /**\r\n     * Genera un fondo con \"píxeles\" animados al estilo retro\r\n     */\r\n    createPixelatedBackground() {\r\n        // Crear contenedor para píxeles\r\n        const pixelContainer = document.createElement('div');\r\n        pixelContainer.className = 'pixel-background';\r\n        \r\n        // Colores en la paleta retro\r\n        const colors = [\r\n            '#b13e53', '#ef7d57', '#ffcd75', \r\n            '#a7f070', '#38b764', '#3b5dc9', \r\n            '#41a6f6', '#73eff7'\r\n        ];\r\n        \r\n        // Generar píxeles\r\n        const pixelCount = 30;\r\n        for (let i = 0; i < pixelCount; i++) {\r\n            const pixel = document.createElement('div');\r\n            pixel.className = 'pixel';\r\n            \r\n            // Posición aleatoria\r\n            const x = Math.random() * 100;\r\n            const y = Math.random() * 100;\r\n            \r\n            // Tamaño aleatorio (pero pequeño)\r\n            const size = Math.random() * 4 + 4;\r\n            \r\n            // Color aleatorio de la paleta\r\n            const color = colors[Math.floor(Math.random() * colors.length)];\r\n            \r\n            // Aplicar estilos\r\n            pixel.style.left = `${x}%`;\r\n            pixel.style.top = `${y}%`;\r\n            pixel.style.width = `${size}px`;\r\n            pixel.style.height = `${size}px`;\r\n            pixel.style.backgroundColor = color;\r\n            pixel.style.opacity = Math.random() * 0.3 + 0.1;\r\n            \r\n            // Animación simple\r\n            pixel.style.animation = `pixel-flicker ${Math.random() * 2 + 1}s infinite steps(2)`;\r\n            \r\n            pixelContainer.appendChild(pixel);\r\n        }\r\n        \r\n        // Añadir al DOM\r\n        this.container.appendChild(pixelContainer);\r\n        \r\n        // Crear estilos para la animación\r\n        const style = document.createElement('style');\r\n        style.textContent = `\r\n            @keyframes pixel-flicker {\r\n                0% { opacity: 0.1; }\r\n                50% { opacity: 0.3; }\r\n                100% { opacity: 0.1; }\r\n            }\r\n        `;\r\n        document.head.appendChild(style);\r\n    }\r\n}\r\n"
        }
    ]
}